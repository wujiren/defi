# 8.1 Go 仿真器参考实现 (Go Simulator Reference Implementation)

> **文档类型：** 架构文档 · 参考实现篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.2 验证层：EVM 仿真与三源预言机](../03_核心执行引擎/3.2_验证层_EVM仿真与三源预言机.md) · [7.2 验证门控 G1-G8 对齐](../07_验证与回测/7.2_验证门控G1-G8对齐.md)
> **下游文档：** [8.2 Python Agent 基类参考实现](./8.2_Python_Agent基类参考实现.md)
>
> **来源文档：** `模块_2_沙盒仿真器.md`（§2.1 StateDB 架构、§2.4 Snapshot/Revert、§2.5 并发模型）；`Go_EVM_Simulator_实现细节.md`（完整代码实现）
>
> **定位说明：** 本文档是 Go EVM 仿真器的**可运行参考实现**，供团队成员理解仿真器内核的工作方式，并作为 Code Review 的基准。生产代码的权威来源是代码仓库，本文档在两者不一致时应以代码仓库为准，并更新本文档。

---

## 1. 仿真器架构总览

Go EVM 仿真器直接使用 `go-ethereum/core/vm` 包运行 EVM，不依赖任何外部 HTTP RPC 调用，核心特性如下：

| 特性 | 说明 |
|---|---|
| **原生 EVM** | 使用 `go-ethereum/core/vm`，行为与主网 EVM 完全一致 |
| **内存 StateDB** | 链上状态全量缓存在内存，消除 RPC 网络延迟 |
| **Snapshot / Revert** | 每次仿真前快照，仿真后回滚，保证状态隔离 |
| **并发安全** | 每个 goroutine 持有独立 StateDB 副本，无全局锁 |
| **性能目标** | 单次仿真 **10–50ms**（P99，StateDB 热缓存命中率 > 90%） |
| **水位线拦截** | 请求区块落后 > 2 个区块时物理阻断，不进入仿真（§3.1）|

---

## 2. Mock StateDB 实现

StateDB 是仿真器的核心数据层，缓存链上账户余额、合约代码、存储槽等状态。

```go
// mock_statedb.go

package simulator

import (
    "math/big"
    "sync"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/state"
)

// MockStateDB 内存态链上状态缓存
// 实现 vm.StateDB 接口，可直接传入 go-ethereum EVM 执行器
type MockStateDB struct {
    mu       sync.RWMutex
    accounts map[common.Address]*accountState
    snapshots []stateSnapshot  // 快照栈，支持多层嵌套
}

type accountState struct {
    balance  *big.Int
    nonce    uint64
    code     []byte
    codeHash common.Hash
    storage  map[common.Hash]common.Hash  // slot → value
}

type stateSnapshot struct {
    id       int
    accounts map[common.Address]*accountState  // 深拷贝
}

// NewMockStateDB 创建空的 StateDB，从 RPC 懒加载状态
func NewMockStateDB(rpc RPCClient, blockNumber uint64) *MockStateDB {
    return &MockStateDB{
        accounts:  make(map[common.Address]*accountState),
        rpcClient: rpc,
        blockNum:  blockNumber,
    }
}

// GetBalance 实现 vm.StateDB 接口
func (s *MockStateDB) GetBalance(addr common.Address) *big.Int {
    s.mu.RLock()
    if acc, ok := s.accounts[addr]; ok {
        s.mu.RUnlock()
        return new(big.Int).Set(acc.balance)
    }
    s.mu.RUnlock()

    // 缓存未命中：从 RPC 加载（懒加载，加载后写入缓存）
    balance, _ := s.rpcClient.GetBalance(addr, s.blockNum)
    s.mu.Lock()
    s.ensureAccount(addr).balance = balance
    s.mu.Unlock()
    return balance
}

// GetState 获取合约存储槽（storage slot）
func (s *MockStateDB) GetState(addr common.Address, key common.Hash) common.Hash {
    s.mu.RLock()
    if acc, ok := s.accounts[addr]; ok {
        if val, ok := acc.storage[key]; ok {
            s.mu.RUnlock()
            return val
        }
    }
    s.mu.RUnlock()

    // 懒加载存储槽
    val, _ := s.rpcClient.GetStorageAt(addr, key, s.blockNum)
    s.mu.Lock()
    s.ensureAccount(addr).storage[key] = val
    s.mu.Unlock()
    return val
}

// Snapshot 创建当前状态快照，返回快照 ID
// 每次仿真前调用，用于仿真后回滚
func (s *MockStateDB) Snapshot() int {
    s.mu.Lock()
    defer s.mu.Unlock()

    snapID := len(s.snapshots)
    // 深拷贝所有账户状态
    snap := stateSnapshot{
        id:       snapID,
        accounts: make(map[common.Address]*accountState, len(s.accounts)),
    }
    for addr, acc := range s.accounts {
        snap.accounts[addr] = acc.deepCopy()
    }
    s.snapshots = append(s.snapshots, snap)
    return snapID
}

// RevertToSnapshot 回滚至指定快照 ID
// 仿真完成后（无论成功或失败）必须调用，保证状态不污染后续请求
func (s *MockStateDB) RevertToSnapshot(snapID int) {
    s.mu.Lock()
    defer s.mu.Unlock()

    if snapID >= len(s.snapshots) {
        return
    }
    // 恢复快照时的账户状态
    s.accounts = s.snapshots[snapID].accounts
    // 弹出此快照及之后的所有快照
    s.snapshots = s.snapshots[:snapID]
}
```

---

## 3. 仿真执行器

```go
// simulator.go

package simulator

import (
    "context"
    "fmt"
    "math/big"
    "time"

    "github.com/ethereum/go-ethereum/core"
    "github.com/ethereum/go-ethereum/core/vm"
    "github.com/ethereum/go-ethereum/params"
)

// EVMSimulator 核心仿真执行器
type EVMSimulator struct {
    stateDB     *MockStateDB
    chainConfig *params.ChainConfig  // 使用 Ethereum Mainnet 配置
    watermark   *SyncSentinel        // 水位线校验（见 §3.1）
    cfg         SimulatorConfig
}

type SimulatorConfig struct {
    WatermarkMaxLag uint64        // 最大允许水位线滞后（默认 2）
    SimulationTimeout time.Duration // 单次仿真超时（默认 100ms）
}

// SimulationResult 仿真执行结果
type SimulationResult struct {
    Success       bool
    GasUsed       uint64
    ReturnData    []byte
    Logs          []*vm.Log
    AmountOut     *big.Int    // 解析自 Logs 的实际输出金额
    Error         string
    DurationMs    int64
}

// Simulate 执行单次 EVM 仿真
func (s *EVMSimulator) Simulate(
    ctx context.Context,
    req *SimulationRequest,
) (*SimulationResult, error) {
    start := time.Now()

    // 步骤 1：Sync Sentinel 水位线拦截
    // 在进入仿真之前，校验请求中的 last_sync_block 是否足够新鲜
    currentBlock := s.watermark.GetCurrentBlock()
    lag := currentBlock - req.LastSyncBlock
    if lag > s.cfg.WatermarkMaxLag {
        return nil, fmt.Errorf("StaleDataError: lag=%d blocks > max=%d",
            lag, s.cfg.WatermarkMaxLag)
    }

    // 步骤 2：快照当前状态（仿真后必须回滚）
    snapID := s.stateDB.Snapshot()
    defer s.stateDB.RevertToSnapshot(snapID)  // 无论成功/失败都回滚

    // 步骤 3：构建 EVM 执行上下文
    blockCtx := vm.BlockContext{
        CanTransfer: core.CanTransfer,
        Transfer:    core.Transfer,
        GetHash:     s.stateDB.GetHash,
        Coinbase:    req.Coinbase,
        BlockNumber: new(big.Int).SetUint64(req.BlockNumber),
        Time:        req.BlockTimestamp,
        GasLimit:    req.GasLimit,
        BaseFee:     req.BaseFee,
    }

    txCtx := vm.TxContext{
        Origin:   req.From,
        GasPrice: req.GasPrice,
    }

    evm := vm.NewEVM(blockCtx, txCtx, s.stateDB, s.chainConfig, vm.Config{
        NoBaseFee: false,  // 生产配置：严格模式，计算 EIP-1559 BaseFee
    })

    // 步骤 4：执行交易
    msg := &core.Message{
        To:         &req.To,
        From:       req.From,
        Nonce:      req.Nonce,
        Value:      req.Value,
        GasLimit:   req.Gas,
        GasPrice:   req.GasPrice,
        GasFeeCap:  req.MaxFeePerGas,
        GasTipCap:  req.MaxPriorityFeePerGas,
        Data:       req.Data,
        AccessList: req.AccessList,
    }

    result, err := core.ApplyMessage(evm, msg, new(core.GasPool).AddGas(req.Gas))
    durationMs := time.Since(start).Milliseconds()

    if err != nil {
        return &SimulationResult{
            Success: false, Error: err.Error(), DurationMs: durationMs,
        }, nil
    }

    if result.Failed() {
        return &SimulationResult{
            Success:    false,
            GasUsed:    result.UsedGas,
            ReturnData: result.ReturnData,
            Error:      fmt.Sprintf("execution reverted: %s", result.Revert()),
            DurationMs: durationMs,
        }, nil
    }

    // 步骤 5：解析 Logs，提取 amountOut
    amountOut := s.parseAmountOut(evm.StateDB.(*MockStateDB).GetLogs(req.To))

    return &SimulationResult{
        Success:    true,
        GasUsed:    result.UsedGas,
        ReturnData: result.ReturnData,
        Logs:       evm.StateDB.(*MockStateDB).GetLogs(req.To),
        AmountOut:  amountOut,
        DurationMs: durationMs,
    }, nil
}
```

---

## 4. Snapshot/Revert 隔离机制

Snapshot/Revert 是仿真器并发安全的核心保证，确保多个并发仿真请求互不干扰：

```
并发场景（50+ Python Agents 同时发起仿真请求）：

Agent-1 → Simulate(req1)                Agent-2 → Simulate(req2)
  snapID=0 = stateDB.Snapshot()           snapID=1 = stateDB.Snapshot()
  evm.Execute(req1.tx)                    evm.Execute(req2.tx)
  result1 = collectLogs()                 result2 = collectLogs()
  stateDB.RevertToSnapshot(0)  ←──────── stateDB.RevertToSnapshot(1)
  return result1                          return result2

关键保证：
  - 每个 goroutine 在 Simulate() 开始时创建独立快照
  - defer RevertToSnapshot() 确保即使 panic 也会执行回滚
  - 两个 goroutine 的快照 ID 不同（原子递增），不相互干扰
```

**G4 模糊测试的 Snapshot 使用模式（1000 轮隔离）：**

```go
func (g *G4FuzzRunner) runRound(agent BaseAgent, params FuzzParams) FuzzResult {
    snapID := g.stateDB.Snapshot()
    defer g.stateDB.RevertToSnapshot(snapID)  // 每轮测试完全隔离

    result := agent.Execute(params)
    return g.evaluate(result)
    // defer 触发回滚，下一轮从干净状态开始
}
```

---

## 5. StateDB 缓存预热

冷启动时 StateDB 为空，所有状态从 RPC 懒加载，首次仿真耗时可能超过 100ms。预热机制在服务启动时主动加载高频访问的合约状态：

```go
// warmup.go

// WarmUpStateDB 服务启动时预热高频合约的 StateDB 缓存
func WarmUpStateDB(stateDB *MockStateDB, protocols []ProtocolConfig, blockNumber uint64) {
    var wg sync.WaitGroup

    for _, protocol := range protocols {
        wg.Add(1)
        go func(p ProtocolConfig) {
            defer wg.Done()

            // 预加载核心合约的存储槽
            for _, slot := range p.HotStorageSlots {
                stateDB.GetState(p.ContractAddress, slot)  // 触发懒加载并缓存
            }

            // 预加载合约代码
            stateDB.GetCode(p.ContractAddress)

            log.Info("warmed up protocol",
                zap.String("protocol", p.ID),
                zap.String("address", p.ContractAddress.Hex()),
                zap.Int("slots_loaded", len(p.HotStorageSlots)),
            )
        }(protocol)
    }

    wg.Wait()
    log.Info("StateDB warmup complete",
        zap.Int("protocols", len(protocols)),
        zap.Uint64("block", blockNumber),
    )
}
```

**预热配置示例（`protocol_warmup.yaml`）：**

```yaml
protocols:
  - id: UNISWAP_V3_ETH
    contract_address: "0x1F98431c8aD98523631AE4a59f267346ea31F984"  # Factory
    hot_storage_slots:
      - "0x00"  # slot0：当前价格、tick、流动性
      - "0x01"  # slot1：协议手续费累计

  - id: AAVE_V3_ETH
    contract_address: "0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2"  # Pool
    hot_storage_slots:
      - "0x00"  # reservesList
      - "0x01"  # reservesData
```

---

## 6. 性能基准与调优

### 6.1 性能指标目标

| 指标 | P50 | P99 | 触发降级条件 |
|---|---|---|---|
| 单次 EVM 仿真（热缓存）| 10ms | 50ms | > 100ms 触发 Go-Execution-Engine 资源检查 |
| StateDB 懒加载（RPC 往返）| 20ms | 100ms | 使用预热机制消除冷启动延迟 |
| G4 模糊测试 1000 轮 | 15s | 30s | — |
| 端到端（含 FSM + 对账）| 200ms | 500ms | P99 > 500ms 触发 §6.3 `HighEndToEndLatency` 告警 |

### 6.2 性能瓶颈排查

当仿真耗时持续超过 50ms P99 时，按以下顺序排查：

```
1. StateDB 缓存命中率（目标 > 90%）
   → 指标: defi_statedb_cache_hit_ratio
   → 处置: 扩大预热 HotStorageSlots 配置

2. Go-Execution-Engine CPU 使用率（目标 < 80%）
   → 指标: container_cpu_usage_seconds{container="go-execution-engine"}
   → 处置: 增大 CPU 配额（§1.2 §3.1）

3. Anvil-Node 响应延迟（StateDB 懒加载依赖）
   → 指标: defi_rpc_request_duration_ms{node="anvil"}
   → 处置: 检查 Anvil 容器内存（tmpfs 是否已满，见 §1.2 §3.3）

4. 并发仿真请求积压
   → 通过 Goroutine 数量和 gRPC 队列深度判断
   → 处置: 检查 50+ Agent 的提交频率是否超过仿真器处理能力
```

---

## 7. 仿真器与真实 EVM 的差异

以下情况仿真结果可能与链上真实执行存在偏差：

| 差异点 | 说明 | 风险等级 | 缓解措施 |
|---|---|---|---|
| Mempool 竞争 | 仿真时不感知其他 pending 交易对链上状态的影响 | 中 | 实盘广播前 MEV Router 的 Flashbots Bundle 模拟（§3.4）补充校验 |
| 多区块时间差 | 仿真基于当前区块，广播和确认可能跨越数个区块 | 低 | FSM BROADCASTED 阶段的 Recovery Manager 监控（§3.3） |
| Gas 价格波动 | 仿真时 Gas Price 为估算值，实际打包时可能不同 | 低 | MEV Router 在广播时按当前 Gas Oracle 重新估算（§3.4） |
| 链重组（Reorg）| 已 CONFIRMED 的交易所在区块可能被重组 | 极低 | FSM REORG 状态和 Recovery Manager 处理（§3.3） |

---

*上一篇：[7.2 验证门控 G1-G8 对齐](../07_验证与回测/7.2_验证门控G1-G8对齐.md) | 下一篇：[8.2 Python Agent 基类参考实现](./8.2_Python_Agent基类参考实现.md)*
