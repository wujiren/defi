# 4.2 资产估值与审计 (Asset Valuation & Audit)

> **文档类型：** 架构文档 · 财务与结算篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [4.1 双分录会计系统](./4.1_双分录会计系统.md) · [3.2 验证层：EVM 仿真与三源预言机](../03_核心执行引擎/3.2_验证层_EVM仿真与三源预言机.md)
> **下游文档：** [5.1 MPC 签名与白名单拦截](../05_安全防御/5.1_MPC签名与白名单拦截.md) · [6.3 告警规则集](../06_可观测性/6.3_告警规则集.md)
>
> **来源文档：** `模块_4_财务会计与数据水位线.md` §4.3 审计与风控感知；§4.2 MtM 公允价值部分

---

## 1. 职责定位

本模块承担两项关联职责：

- **资产估值（Valuation）：** 基于三源预言机中位价，实时计算所有持仓的 U 本位净值（NAV），为 AI 决策和风控熔断提供准确的资产基准
- **交易后审计（Post-Trade Audit）：** 每笔交易 CONFIRMED 后，复盘实际执行质量，识别软滑点损耗和毒性流，将审计结果写入 AI 反馈飞轮

这两项职责共享同一套数据源（三源预言机 + 链上收据），因此合并为一个模块。

---

## 2. 实时 MtM 估值（Mark-to-Market）

### 2.1 估值计算口径

**NAV（净资产价值）= 已实现资产 + 未领取奖励 - 未偿还债务**

所有资产统一折算为 **USDC（6 位小数，U 本位）**，使用三源预言机**中位价**，不使用 DEX Slot0 即时价（防闪电贷操纵）。

```go
// MtMCalculator 实时净值计算器
type MtMCalculator struct {
    oracle    OracleAggregator  // 三源预言机聚合（见 §3.2）
    ledger    LedgerReader
    rewards   RewardScanner
}

// CalcNAV 计算指定策略的实时净值
func (m *MtMCalculator) CalcNAV(
    ctx context.Context,
    strategyID string,
    atBlock uint64,
) (*NAVResult, error) {
    // 1. 读取已实现资产余额（来自 asset_balances 表）
    balances, err := m.ledger.GetAssetBalances(strategyID)
    if err != nil {
        return nil, err
    }

    // 2. 读取未领取奖励（来自 unclaimed_rewards 表）
    rewards, err := m.rewards.GetUnclaimed(strategyID)
    if err != nil {
        return nil, err
    }

    // 3. 合并所有持仓，按代币聚合
    allPositions := mergePositions(balances, rewards)

    // 4. 逐代币估值（使用三源中位价）
    totalNavUSDC := new(big.Int)
    for _, pos := range allPositions {
        medianPrice, err := m.oracle.GetMedianPrice(ctx, pos.TokenAddress, atBlock)
        if err != nil {
            // 预言机不可用时，使用上一次有效价格（带 STALE 标记）
            medianPrice = m.oracle.GetLastKnownPrice(pos.TokenAddress)
            m.logger.Warn("using stale price for NAV",
                zap.String("token", pos.TokenAddress),
                zap.String("strategy", strategyID),
            )
        }
        posValueUSDC := new(big.Int).Mul(pos.RawBalance, medianPrice)
        posValueUSDC.Div(posValueUSDC, pos.PriceDecimals) // 归一化精度
        totalNavUSDC.Add(totalNavUSDC, posValueUSDC)
    }

    // 5. 减去未偿债务（借贷协议负债，如 Aave 借款）
    debts, _ := m.ledger.GetDebts(strategyID)
    for _, debt := range debts {
        debtValueUSDC := m.oracle.PriceToUSDC(debt)
        totalNavUSDC.Sub(totalNavUSDC, debtValueUSDC)
    }

    return &NAVResult{
        StrategyID:   strategyID,
        TotalNavUSDC: totalNavUSDC,
        AtBlock:      atBlock,
        Timestamp:    time.Now(),
    }, nil
}
```

### 2.2 MtM 快照频率

| 场景 | 更新频率 | 写入目标 |
|---|---|---|
| 实盘运行中 | 每区块（约 12 秒）更新一次 | `mtm_snapshots` 表 + Prometheus Gauge |
| 策略评估期（EVALUATED）| 每次 Tick 数据到达时 | 回测报告 |
| 影子模式（SHADOWED）| 每区块更新，对比假设 PnL 与真实市场 | 影子模式对比报告（G7 输入） |

### 2.3 最大回撤实时监控

实时 MDD 基于 MtM NAV 序列动态计算，触发告警逻辑由 §6.3 定义：

```
实时 MDD = (历史最高 NAV - 当前 NAV) / 历史最高 NAV

告警触发条件（来自 PRD 评估指标体系 §4.1）：
  实时 MDD > 回测 MDD × 1.5 → CRITICAL 告警 → 触发策略自动暂停
```

---

## 3. 软滑点审计（Soft Slippage Audit）

### 3.1 定义

**软滑点** = 实际成交价与提议时市场价的偏差，反映策略对市场的真实冲击成本。

它与**硬滑点**（`max_slippage_bps`，超出则交易被拒绝）的区别：
- 硬滑点是**事前拦截**（保护机制）
- 软滑点是**事后审计**（质量追踪）

### 3.2 计算方式

```go
// SoftSlippageAudit 交易确认后立即执行
func (a *Auditor) SoftSlippageAudit(
    task *TradeTask,
    receipt *TradeReceipt,
) *SlippageAuditResult {
    // 1. 提议时的市场参考价（由 Python Agent 在 TradeRequest 发送时记录）
    proposalPrice := task.ProposalMarketPrice  // 单位：Token B per Token A

    // 2. 实际成交价（从链上 receipt 解析）
    actualPrice := calcActualPrice(receipt.AmountIn, receipt.AmountOut)

    // 3. 滑点 = (提议价 - 实际价) / 提议价
    //    正值表示价格向不利方向滑动（买入时实际收到更少）
    slippageBps := calcBps(proposalPrice, actualPrice)

    // 4. 写入 ledger_entries（entry_type = "SLIPPAGE"）
    slippageLoss := calcAbsoluteLoss(slippageBps, receipt.AmountOut)
    a.ledger.WriteSlippageEntry(task.ID, task.TraceID, slippageLoss)

    return &SlippageAuditResult{
        TraceID:      task.TraceID,
        ExpectedBps:  task.MaxSlippageBps,
        ActualBps:    slippageBps,
        AbsoluteLoss: slippageLoss,
    }
}
```

### 3.3 滑点异常处理

| 软滑点水平 | 处理方式 |
|---|---|
| 0 – `max_slippage_bps` 范围内 | 正常记录，写入 AI 反馈飞轮作为优化参考 |
| 超过 `max_slippage_bps` | 写入高危事件日志，触发 §6.3 `HighSlippage` 告警 |
| 超过 `max_slippage_bps × 2` | 同时触发策略暂停，等待人工审查 |

---

## 4. 毒性流分析（Toxic Flow Audit）

### 4.1 什么是毒性流

**毒性流（Toxic Flow）**：策略交易发出后，价格持续向持仓不利方向移动，说明策略正在被知情套利者（Informed Traders）反向收割。

典型表现：策略买入 Token A → 价格随即下跌 → 下跌幅度超过正常波动基线。

这与 MEV 三明治攻击不同：毒性流是**交易执行后的持续逆向移动**，MEV 是**交易执行时的即时夹击**。

### 4.2 检测算法

```go
// ToxicFlowDetector 在每笔交易 CONFIRMED 后，追踪后续 N 个区块的价格变化
func (d *ToxicFlowDetector) Analyze(
    ctx context.Context,
    task *TradeTask,
    confirmedBlock uint64,
) *ToxicFlowResult {
    // 1. 记录执行时价格（确认区块）
    entryPrice, _ := d.oracle.GetMedianPrice(ctx, task.TokenOut, confirmedBlock)

    // 2. 等待 N 个区块后（默认 N=10，约 2 分钟）检查价格
    followupPrice, _ := d.oracle.GetMedianPrice(ctx, task.TokenOut, confirmedBlock+10)

    // 3. 计算持仓后的价格变化（买入时，负值为不利）
    priceChangeBps := calcBps(entryPrice, followupPrice)

    // 4. 毒性流判断：持续逆向移动超过阈值
    isToxic := false
    if task.Action == SWAP_BUY && priceChangeBps < -d.cfg.ToxicFlowThresholdBps {
        isToxic = true
    } else if task.Action == SWAP_SELL && priceChangeBps > d.cfg.ToxicFlowThresholdBps {
        isToxic = true
    }

    result := &ToxicFlowResult{
        TraceID:        task.TraceID,
        EntryPrice:     entryPrice,
        FollowupPrice:  followupPrice,
        PriceChangeBps: priceChangeBps,
        IsToxic:        isToxic,
    }

    if isToxic {
        // 5. 写入 ledger_entries（entry_type = "MEV_LOSS"，为估算值）
        estimatedLoss := calcAbsoluteLoss(abs(priceChangeBps), task.AmountOut)
        d.ledger.WriteMEVLossEntry(task.ID, task.TraceID, estimatedLoss)

        // 6. 触发自动暂停（若同一策略连续 3 次检测到毒性流）
        d.checkAutoSuspend(task.StrategyID, result)
    }

    return result
}

// checkAutoSuspend 连续毒性流触发策略暂停
func (d *ToxicFlowDetector) checkAutoSuspend(strategyID string, result *ToxicFlowResult) {
    count := d.recentToxicCount.Incr(strategyID)
    if count >= d.cfg.AutoSuspendThreshold {  // 默认 3 次
        d.strategyManager.Pause(strategyID, "TOXIC_FLOW_DETECTED")
        d.alertManager.FireWarning("ToxicFlowDetected", map[string]interface{}{
            "strategy_id":  strategyID,
            "recent_count": count,
        })
    }
}
```

### 4.3 毒性流的根因分析

毒性流持续出现通常意味着以下问题之一，AI 反馈飞轮（§6.4）会基于审计结果生成对应的优化 Prompt：

| 根因 | 特征 | 优化方向 |
|---|---|---|
| 信号延迟 | `last_sync_block` 与确认区块差值大 | 优化推理耗时，降低水位线滞后 |
| 市场冲击过大 | 单笔交易规模超过流动性深度的 1% | 拆分为 TWAP 分批执行 |
| 信号被 MEV 机器人识别 | 公共 Mempool 路由 + 策略信号重复性高 | 切换至 Flashbots 私有路由（§3.4） |
| 策略本身信息含量低 | 随机市场中持续逆向 | 策略逻辑优化，进入重评估流程 |

---

## 5. 审计数据写入 AI 反馈飞轮

每笔交易的审计结果通过 `stream:internal:accounting` Redis Stream 异步传递给 AI-Feedback-Service（Zone A）：

```
触发时机：Toxic Flow 或软滑点分析完成后

写入格式（Protobuf 序列化至 Redis Stream）：
{
  "trace_id": "...",
  "strategy_id": "...",
  "audit_type": "SLIPPAGE" | "TOXIC_FLOW",
  "slippage_bps": 35,
  "price_change_bps": -180,
  "recommended_action": "switch_to_twap" | "use_flashbots" | "reduce_position_size",
  "ledger_loss_usdc": "1234000000"   // 6 位小数的 USDC，string 格式
}
```

AI-Feedback-Service 根据 `recommended_action` 字段生成对应的优化 Prompt，详见 §6.4。

---

## 6. 评价标准

| 维度 | 好架构 | 坏架构 |
|---|---|---|
| **估值准确性** | 三源中位价每区块更新，NAV 误差 ≤ 1 wei | 使用 Slot0 即时价，闪电贷攻击期间 NAV 严重失真 |
| **回撤响应速度** | 实时 MDD 超限 1 个区块内触发告警 | 依赖每日报表，回撤已发展为严重损失才发现 |
| **软滑点追踪** | 每笔交易记录提议价 vs 实际价偏差，写入 AI 飞轮 | 只看"是否成交"，不追踪执行质量 |
| **毒性流识别** | 连续 3 次毒性流自动暂停，防止策略持续被收割 | 无毒性流检测，策略在低信息优势场景中持续亏损 |
| **审计时效** | 交易 CONFIRMED 后 60 秒内完成滑点+毒性流分析 | 仅在周报中手动复盘，反馈严重滞后 |

---

*上一篇：[4.1 双分录会计系统](./4.1_双分录会计系统.md) | 下一篇：[5.1 MPC 签名与白名单拦截](../05_安全防御/5.1_MPC签名与白名单拦截.md)*
