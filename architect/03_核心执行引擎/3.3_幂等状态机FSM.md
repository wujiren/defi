# 3.3 幂等状态机 FSM (Idempotent Finite State Machine)

> **文档类型：** 架构文档 · 核心执行引擎篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.2 验证层](./3.2_验证层_EVM仿真与三源预言机.md) · [5.1 MPC 签名与白名单拦截](../05_安全防御/5.1_MPC签名与白名单拦截.md)
> **下游文档：** [3.4 MEV 路由与防夹执行](./3.4_MEV路由与防夹执行.md) · [4.1 双分录会计系统](../04_财务与结算/4.1_双分录会计系统.md)
>
> **来源文档：** `模块_3_幂等状态机__FSM_.md`

---

## 1. 核心设计哲学

FSM 是系统在对抗性链上环境中的**确定性执行保证**。核心原则：

> **先写日志，后发交易（Write-Ahead Log）**

每次状态变更必须先写入 PostgreSQL 并提交事务，再执行链上动作。这确保了无论进程在何时崩溃——签名前、广播后、确认期间——系统重启后都能从数据库精确恢复，且对同一笔交易的处理结果永远唯一（幂等性）。

**幂等性保证：** 同一个 `internal_tx_id` 无论经历多少次重试、重启、Recovery Manager 介入，链上最终只会产生一笔交易，且 Nonce 唯一、不冲突。

---

## 2. 状态流转全景

### 2.1 主干路径与异常路径

```
                           ┌──────────────────┐
  gRPC TradeRequest        │      INIT         │  分配 internal_tx_id，写入 DB
  ─────────────────────→   └────────┬─────────┘
                                    │ 三源预言机 + EVM 仿真 + 不变性断言（§3.2）
                                    │ 全部通过
                           ┌────────▼─────────┐
                           │    SIMULATED      │  仿真结果持久化
                           └────────┬─────────┘
                                    │ 大额审批校验（§5.1）
                        ┌───────────┴──────────────┐
                        │ 未触发大额阈值              │ 触发大额阈值
                        │                  ┌────────▼──────────┐
                        │                  │  PENDING_APPROVAL  │  等待管理员确认
                        │                  └────────┬──────────┘
                        │                           │ 管理员审批通过
                        └──────────────┬────────────┘
                                       │ 获取 Nonce 锁，发送至 Zone C 签名
                           ┌───────────▼──────────┐
                           │       SIGNED          │  Nonce 已分配，严禁重签
                           └───────────┬──────────┘
                                       │ MEV Router 广播（§3.4）
                           ┌───────────▼──────────┐
                           │     BROADCASTED       │  tx_hash 已记录
                           └───────────┬──────────┘
                                       │ 监听链上包含，达到安全确认数
                           ┌───────────▼──────────┐
                           │      CONFIRMED        │  触发双分录对账（§4.1）
                           └──────────────────────┘

异常路径：
  任意阶段验证失败 → FAILED（系统内部拦截，不进链上）
  链上 EVM 执行失败 → REVERTED（链上 Revert，Gas 已消耗）
  BROADCASTED 超时 → Gas 阶梯加速（自愈，保持 BROADCASTED）
  链重组检测 → 回滚至 SIMULATED，重新评估
```

### 2.2 各状态详细说明

| 状态 | 进入条件 | 执行动作与持久化 | 崩溃自愈逻辑 | 可观测性埋点 (fsm_state_count) |
|---|---|---|---|---|
| **INIT** | gRPC 接收 TradeRequest 且 Sync Sentinel 通过 | 创建 `trade_tasks` 记录，分配 `internal_tx_id` | 重启后扫描：重新进入仿真流程 | `from: null, to: INIT` |
| **SIMULATED** | 三源预言机 + EVM 仿真 + 不变性断言全部通过 | 持久化仿真结果（预期 Gas、输出金额） | 重启后扫描：重新仿真，校验当前链上水位线是否已变化 | `from: INIT, to: SIMULATED` |
| **PENDING_APPROVAL** | 单笔价值超过大额审批阈值（见 §0.6） | 通知管理员，FSM 挂起等待 | 重启后：继续等待，不重新提交仿真 | `from: SIMULATED, to: PENDING_APPROVAL` |
| **SIGNED** | MPC 签名完成，Nonce 已分配 | 持久化 `nonce` + `signed_payload`，**严禁重签** | 重启后：若 `tx_hash IS NULL`，直接用原 signed_payload 重广播 | `from: SIMULATED/PENDING_APPROVAL, to: SIGNED` |
| **BROADCASTED** | Signed Payload 推送至 RPC 或 Flashbots | 持久化 `tx_hash` | 重启后：用 `tx_hash` 查询收据；超时触发 Gas 加速 | `from: SIGNED, to: BROADCASTED` |
| **CONFIRMED** | 链上达到 `tx_confirmation_blocks` 个安全确认 | 触发 §4.1 双分录对账，释放 Nonce 锁 | — （终态，已完成） | `from: BROADCASTED, to: CONFIRMED` |
| **REVERTED** | 链上 EVM 执行返回 Revert | 记录错误原因，触发 §6.3 告警 | — （终态，不重试） |
| **FAILED** | 系统内部拦截（熔断/白名单拒绝/断言破线） | 记录失败原因和错误码 | — （终态，不重试） |

---

## 3. Nonce 锁：原子化双写

Nonce 管理是 FSM 幂等性的物理基础。系统用 PostgreSQL 行级锁实现分布式 Nonce 分配，确保 50+ Agent 并发发单时，同一地址的 Nonce 严格递增且唯一。

### 3.1 SIGNED 阶段原子事务

```go
// nonce_manager.go
func (m *NonceManager) AcquireAndSign(
    ctx context.Context,
    task *TradeTask,
) error {
    return m.db.WithTransaction(ctx, func(tx *sql.Tx) error {

        // ── 步骤 1：行级锁，获取当前 Nonce ────────────────────────────
        // FOR UPDATE 确保同一时刻只有一个 goroutine 能操作此地址的 Nonce
        var nextNonce int64
        err := tx.QueryRowContext(ctx, `
            SELECT next_nonce
            FROM   nonce_locks
            WHERE  address  = $1
              AND  chain_id = $2
            FOR UPDATE
        `, task.FromAddress, task.ChainID).Scan(&nextNonce)
        if err != nil {
            return fmt.Errorf("nonce lock acquire failed: %w", err)
        }

        // ── 步骤 2：更新 trade_tasks 状态为 SIGNED，绑定 Nonce ─────────
        _, err = tx.ExecContext(ctx, `
            UPDATE trade_tasks
            SET    status    = 'SIGNED',
                   nonce     = $1,
                   updated_at = NOW()
            WHERE  internal_tx_id = $2
              AND  status = 'SIMULATED'   -- 防止重复签名
        `, nextNonce, task.InternalTxID)
        if err != nil {
            return err
        }

        // ── 步骤 3：Nonce 递增 ──────────────────────────────────────────
        _, err = tx.ExecContext(ctx, `
            UPDATE nonce_locks
            SET    next_nonce = next_nonce + 1,
                   locked_at  = NOW()
            WHERE  address  = $1
              AND  chain_id = $2
        `, task.FromAddress, task.ChainID)
        if err != nil {
            return err
        }

        // ── 步骤 4：发送签名请求至 Zone C（事务提交后执行）────────────
        // 注意：签名请求在事务提交后发出，避免签名成功但 DB 提交失败的不一致
        task.Nonce = nextNonce
        return nil
    })
    // 事务提交成功后，再异步发送 MPC 签名请求
}
```

**幂等性保证：** `WHERE status = 'SIMULATED'` 条件确保 UPDATE 只在正确的状态下执行，重复调用不会二次分配 Nonce。若 MPC 签名失败，Nonce 已被分配但未使用，Recovery Manager 会检测并用该 Nonce 重新广播。

---

## 4. 自愈管理器（Recovery Manager）

Recovery Manager 是 Go 执行层的**后台常驻服务**，处理所有因进程崩溃、网络断线、Gas 卡单导致的未完成任务。

### 4.1 启动时全量状态扫描

```go
// recovery_manager.go
type RecoveryManager struct {
    db         DBReader
    broadcaster ITxBroadcaster
    gasOracle  GasOracle
    cfg        RecoveryConfig
}

// StartRecovery 在 Go 执行引擎启动时调用，处理上次宕机遗留的未完成任务
func (m *RecoveryManager) StartRecovery(ctx context.Context) {
    m.logger.Info("recovery manager: starting boot scan")

    // 1. 处理 SIGNED 且未广播的任务（签名后崩溃）
    m.recoverSignedTasks(ctx)

    // 2. 处理 BROADCASTED 且未确认的任务（广播后断线）
    m.recoverBroadcastedTasks(ctx)

    // 3. 处理 PENDING_APPROVAL 超时的任务（审批超时告警）
    m.checkPendingApprovalTimeout(ctx)

    m.logger.Info("recovery manager: boot scan completed")
}

// RunPeriodicScan 运行期间定期扫描（每 30 秒）
func (m *RecoveryManager) RunPeriodicScan(ctx context.Context) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            m.recoverBroadcastedTasks(ctx) // 主要处理 Gas 卡单
        case <-ctx.Done():
            return
        }
    }
}
```

### 4.2 各异常场景的确定性自愈

```go
// 场景一：签名后崩溃（SIGNED 且 tx_hash 为空）
func (m *RecoveryManager) recoverSignedTasks(ctx context.Context) {
    tasks, _ := m.db.QueryTasks(ctx,
        "SELECT * FROM trade_tasks WHERE status = 'SIGNED' AND tx_hash IS NULL")

    for _, task := range tasks {
        // 直接用 DB 中已存储的 signed_payload 重新广播
        // 严禁重新分配 Nonce 或重新签名
        txHash, err := m.broadcaster.Rebroadcast(ctx, task.SignedPayload)
        if err != nil {
            m.logger.Error("rebroadcast failed", zap.String("id", task.ID), zap.Error(err))
            continue
        }
        m.db.UpdateTaskHash(ctx, task.ID, txHash, "BROADCASTED")
        m.logger.Info("recovered SIGNED task", zap.String("id", task.ID), zap.String("tx_hash", txHash))
    }
}

// 场景二：广播后未确认（BROADCASTED）
func (m *RecoveryManager) recoverBroadcastedTasks(ctx context.Context) {
    tasks, _ := m.db.QueryTasks(ctx,
        "SELECT * FROM trade_tasks WHERE status = 'BROADCASTED'")

    for _, task := range tasks {
        receipt, err := m.rpc.GetTransactionReceipt(ctx, task.TxHash)

        switch {
        case err == nil && receipt != nil:
            // 交易已上链
            if receipt.Status == 1 {
                m.db.UpdateTaskStatus(ctx, task.ID, "CONFIRMED")
                m.triggerAccounting(ctx, task, receipt) // 触发 §4.1 双分录对账
            } else {
                m.db.UpdateTaskStatus(ctx, task.ID, "REVERTED")
            }

        case err == nil && receipt == nil:
            // 交易在 Mempool 中丢失，检查是否需要 Gas 加速
            m.handleStuckTask(ctx, task)

        default:
            // RPC 查询失败，下次扫描重试
            m.logger.Warn("receipt query failed", zap.String("hash", task.TxHash), zap.Error(err))
        }
    }
}
```

### 4.3 阶梯 Gas 加速

```go
// 场景三：Gas 过低卡单（BROADCASTED 超时）
func (m *RecoveryManager) handleStuckTask(ctx context.Context, task *TradeTask) {
    // 校验是否超过加速时间阈值（配置键: gas_acceleration_timeout_min）
    if time.Since(task.UpdatedAt) < m.cfg.GasAccelerationTimeout {
        return
    }

    // 获取当前市场 Gas 价格并上浮（配置键: gas_acceleration_pct）
    currentGas, _ := m.gasOracle.SuggestPrice(ctx)
    multiplier    := 100 + m.cfg.GasAccelerationPct
    newGasPrice   := new(big.Int).Mul(currentGas, big.NewInt(int64(multiplier)))
    newGasPrice.Div(newGasPrice, big.NewInt(100))

    // 关键约束：使用相同的 Nonce 和相同的 to_address（替换交易，非新交易）
    newPayload, err := m.adapter.ReplaceGas(task.SignedPayload, newGasPrice)
    if err != nil {
        m.logger.Error("gas replacement failed", zap.String("id", task.ID), zap.Error(err))
        return
    }

    // 重新签名（使用原 Nonce）并广播
    // 注意：此处需要重新经过 Zone C 签名，因为 Gas 字段变化导致交易哈希变化
    newTxHash, err := m.broadcaster.Broadcast(ctx, newPayload)
    if err != nil {
        return
    }

    // 更新 tx_hash，状态保持 BROADCASTED
    m.db.UpdateTaskGasAndHash(ctx, task.ID, newGasPrice.String(), newTxHash)
    m.logger.Info("gas acceleration applied",
        zap.String("id", task.ID),
        zap.String("new_hash", newTxHash),
        zap.String("new_gas_price", newGasPrice.String()),
    )
}
```

### 4.4 链重组处理

```go
// 场景四：链重组（Reorg）
func (m *RecoveryManager) detectAndHandleReorg(ctx context.Context, task *TradeTask) {
    // 获取 task.tx_hash 所在区块的当前哈希
    confirmedBlock, _ := m.rpc.GetBlockByNumber(ctx, task.ConfirmedBlockNumber)

    if confirmedBlock.Hash != task.ConfirmedBlockHash {
        // 区块哈希变化，确认发生链重组
        m.logger.Warn("chain reorg detected",
            zap.String("id", task.ID),
            zap.String("expected_block_hash", task.ConfirmedBlockHash),
            zap.String("actual_block_hash", confirmedBlock.Hash),
        )

        // **防守型覆盖与回滚（Defensive Cancellation）：**
        // 1. 发现 Reorg 时，原交易并未消失，可能仍游荡在 Mempool 中。
        // 2. **绝不能直接回滚 FSM**，必须先发送一笔“防守型覆盖交易”（使用与原交易相同的 Nonce，发送 0 ETH 给自己，附带极高的 Priority Fee）。
        // 3. 监控该 0 ETH 取消交易 `CONFIRMED` 后，物理确保原交易已失效。
        // 4. 此时，再将原任务 FSM 状态回滚至 `SIMULATED`，等待策略重新评估。不执行此操作将面临极大的“双花/幽灵资产”错乱风险。
        m.db.UpdateTaskStatus(ctx, task.ID, "SIMULATED")

        // 触发 P1 告警
        m.alerter.Alert(ctx, "CHAIN_REORG_DETECTED", map[string]string{
            "internal_tx_id": task.ID,
            "tx_hash":        task.TxHash,
            "block_number":   fmt.Sprintf("%d", task.ConfirmedBlockNumber),
        })
    }
}
```

---

## 5. 自愈性能指标

| 指标 | 目标值 | 说明 |
|---|---|---|
| **启动恢复耗时** | < 15 秒 | 从进程崩溃到 Recovery Manager 完成全量扫描 |
| **Gas 加速响应** | `gas_acceleration_timeout_min`（见 README §0.6） | BROADCASTED 后超时触发第一次加速 |
| **幂等重试次数** | 无上限 | 同一 `internal_tx_id` 可安全重试任意次，结果唯一 |
| **Nonce 冲突率** | 0% | 行级锁保证串行，物理上不可能产生冲突 |

---

## 6. 跨链库存再平衡（Active Rebalancing）

多链资金调度使用 FSM 的**链式触发**模式——每一步（Hop）都是一个独立的 FSM 任务，前一跳 CONFIRMED 是后一跳 INIT 的触发器：

```
Ethereum → Arbitrum 资金再平衡：

  FSM Task A（Ethereum）                FSM Task B（Arbitrum）
  ─────────────────────                 ─────────────────────
  INIT → ... → CONFIRMED
       └── 触发 Task B 创建 ──────────→ INIT → ... → CONFIRMED
                                               └── 更新跨链在途记录（§2.3）

监控指标：
  Util_Rate = (Total - Idle) / Total
  当 Util_Rate > 阈值时，触发再平衡任务链
```

每一跳写入 §2.3 的 `cross_chain_transit` 表，确保在途资金在双链账本中正确记录。

---

*上一篇：[3.2 验证层](./3.2_验证层_EVM仿真与三源预言机.md) | 下一篇：[3.4 MEV 路由与防夹执行](./3.4_MEV路由与防夹执行.md)*
