# 3.1 策略 Agent 与水位线拦截 (Strategy Agent & Sync Sentinel)

> **文档类型：** 架构文档 · 核心执行引擎篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [2.1 Protobuf 契约](../02_数据总线与契约/2.1_Protobuf契约.md) · [2.2 Redis Stream 实时管道](../02_数据总线与契约/2.2_Redis_Stream实时管道.md)
> **下游文档：** [3.2 验证层](./3.2_验证层_EVM仿真与三源预言机.md)
>
> **合并说明：** 本文档由以下两份旧文档合并而来：
> - `模块_4_财务会计与数据水位线.md`（§4.1 Sync Sentinel 架构 + §4.5 Go 实现）
> - `Python_模块_策略_Agent_的_gRPC_客户端基类.md`（BaseStrategyAgent 实现）
>
> **职责边界：** Sync Sentinel（Go 端硬拦截）在前，Python Agent 基类（Zone A 消费端）在后。
> 两者通过 `Context.last_sync_block` 字段联动，构成水位线校验的完整闭环。

---

## 1. 设计概述

本文档覆盖执行链路的**入口两端**：

```
Zone A                                   Zone B
─────────────────────────────            ──────────────────────────────────
Python BaseStrategyAgent                 Go Sync Sentinel
  · 消费 Redis Stream 链上事件             · 接收 gRPC TradeRequest
  · 更新本地 last_seen_block              · 对比 CurrentBlock vs last_sync_block
  · 本地辅助水位线校验（非硬拦截）          · 硬拦截：lag > watermark_max_lag → StaleDataError
  · 构造 Context（含水位线）               · 通过 → 交给 §3.2 验证层
  · 发送 gRPC ExecuteTrade / ShadowTrade
```

**重要边界：** Zone A 的本地水位线校验是**辅助性**的，可以提前发现过期状态避免无效网络往返。Zone B 的 Sync Sentinel 才是**强制性硬拦截**，是系统安全边界，不可绕过。

---

## 2. Go 端：Sync Sentinel（水位线拦截器）

### 2.1 核心拦截逻辑

Sync Sentinel 作为 Go 执行引擎的**第一道中间件**，在每笔 TradeRequest 进入仿真流程前强制执行：

```go
// sync_sentinel.go
package sentinel

import (
    "context"
    "errors"
    "fmt"

    "go.uber.org/zap"
)

var ErrStaleData = errors.New("StaleDataError")

type SyncSentinel struct {
    maxLag uint64 // 对应配置键: watermark_max_lag（默认值见 README §0.6）
    db     DBReader
    rpc    RPCReader
    logger *zap.Logger
}

// CheckWatermark 是每笔 TradeRequest 进入仿真前的强制拦截点
// 调用方：Go-Execution-Engine 的 gRPC Handler
func (s *SyncSentinel) CheckWatermark(
    ctx context.Context,
    req *proto.TradeRequest,
) error {
    // 1. 获取 Go 端当前已确认的最新区块高度
    currentBlock, err := s.rpc.GetLatestBlock(ctx)
    if err != nil {
        // RPC 不可用时拒绝所有请求（fail-safe）
        return fmt.Errorf("%w: RPC unavailable: %v", ErrStaleData, err)
    }

    // 2. 从请求 Context 中提取 Agent 上报的水位线
    agentBlock := req.Ctx.LastSyncBlock

    // 3. 计算水位线滞后
    if currentBlock < agentBlock {
        // Agent 上报的块高比 Go 端还新，可能是时序问题，拒绝
        return fmt.Errorf("%w: agent block %d > current block %d",
            ErrStaleData, agentBlock, currentBlock)
    }
    lag := currentBlock - agentBlock

    // 4. 硬拦截：滞后超过阈值
    if lag > s.maxLag {
        s.logger.Warn("watermark lag exceeded, circuit breaker triggered",
            zap.Uint64("current_block", currentBlock),
            zap.Uint64("agent_block", agentBlock),
            zap.Uint64("lag", lag),
            zap.Uint64("max_lag", s.maxLag),
            zap.String("trace_id", req.Ctx.TraceId),
        )
        return fmt.Errorf("%w: lag=%d blocks (max=%d), current=%d, agent_seen=%d",
            ErrStaleData, lag, s.maxLag, currentBlock, agentBlock)
    }

    return nil
}
```

### 2.2 在 gRPC Handler 中的调用位置

```go
// trading_handler.go — gRPC 服务端实现
func (h *TradingHandler) ExecuteTrade(
    ctx context.Context,
    req *proto.TradeRequest,
) (*proto.TradeResponse, error) {

    // ── 第一步：Sync Sentinel 水位线硬拦截 ────────────────────────────
    if err := h.sentinel.CheckWatermark(ctx, req); err != nil {
        return &proto.TradeResponse{
            Status:       proto.TradeStatus_FAILED,
            ErrorMessage: err.Error(), // "StaleDataError: lag=5 blocks..."
        }, nil
        // 注意：此处返回 nil error（gRPC 层不报错），
        // 业务错误通过 TradeResponse.error_message 传递
    }

    // ── 第二步：写入数据库，分配 Internal Tx ID ───────────────────────
    task, err := h.db.CreateTradeTask(ctx, req)
    if err != nil {
        return nil, err
    }

    // ── 第三步：进入验证层（§3.2）────────────────────────────────────
    go h.pipeline.Run(ctx, task)

    return &proto.TradeResponse{
        InternalTxId: task.ID.String(),
        Status:       proto.TradeStatus_INIT,
    }, nil
}
```

### 2.3 数据库水位线的维护

Sync Sentinel 校验的是 **RPC 最新块** vs **Agent 上报块**，而非数据库同步块。
数据库的 `last_updated_block` 字段（见 §3.5 `asset_balances` 表）用于余额新鲜度校验，是独立的第二道水位线：

| 水位线类型 | 维护方 | 用途 | 熔断条件 | 配置键 |
|---|---|---|---|---|
| **Agent 水位线** | Python Agent 维护的 `last_seen_block` | Sync Sentinel 校验 Agent 数据新鲜度 | `CurrentBlock - agent_block > watermark_max_lag` | `watermark_max_lag` |
| **余额水位线** | Go 余额扫描模块写入 `asset_balances.last_updated_block` | 对账模块校验余额数据新鲜度 | `CurrentBlock - balance_block > balance_stale_blocks` | `balance_stale_blocks` |
| **价格水位线** | 预言机模块写入 `last_price_update` 时间戳 | 三源预言机校验价格新鲜度 | 数据时间戳 > `price_stale_threshold_sec` | `price_stale_threshold_sec` |

---

## 3. Python 端：BaseStrategyAgent（策略 Agent 基类）

### 3.1 核心基类实现

```python
# base_agent.py
import grpc
import uuid
import time
from decimal import Decimal
from typing import Optional
from abc import ABC, abstractmethod

from defi.v1 import trading_pb2, trading_pb2_grpc, common_pb2


class BaseStrategyAgent(ABC):
    """
    策略 Agent 基类：处理 gRPC 通信、精度转换、水位线感知与全链路追踪。

    子类只需实现 evaluate_strategy()，无需关心底层通信细节。
    """

    def __init__(self, agent_id: str, grpc_endpoint: str):
        self.agent_id = agent_id
        # Zone A → Zone B 的 gRPC 连接（TLS 配置见 §1.3）
        self.channel = grpc.secure_channel(
            grpc_endpoint,
            grpc.ssl_channel_credentials()
        )
        self.stub = trading_pb2_grpc.TradingEngineStub(self.channel)
        # 本地维护的数据水位线（从 Redis Stream 消费时更新）
        self.last_seen_block: int = 0

    # ── 水位线管理 ──────────────────────────────────────────────────────

    def on_chain_event(self, event: common_pb2.ChainEvent) -> None:
        """
        Redis Stream 消费回调（由 §2.2 RedisStreamConsumer 调用）。
        更新本地水位线后调用策略推理逻辑。
        """
        self.last_seen_block = event.block_number
        self.evaluate_strategy(event)

    def _check_local_watermark(self) -> bool:
        """
        本地辅助水位线校验（非硬拦截，仅用于提前放弃无效请求）。
        真正的硬拦截由 Zone B 的 Sync Sentinel 执行。
        """
        if self.last_seen_block == 0:
            return False  # 尚未收到任何链上数据，不发单
        return True

    # ── 上下文构造 ──────────────────────────────────────────────────────

    def _build_context(self) -> common_pb2.Context:
        """
        构造 TradeRequest 的 Context，携带 Trace ID 和当前水位线。
        Sync Sentinel 在 Go 端依赖此处的 last_sync_block 字段。
        """
        return common_pb2.Context(
            trace_id=str(uuid.uuid4()),       # 全链路追踪 ID（UUID v4）
            agent_id=self.agent_id,
            last_sync_block=self.last_seen_block,  # 水位线：Agent 当前所见的最新块高
            timestamp_ms=int(time.time() * 1000),
        )

    # ── 精度转换 ────────────────────────────────────────────────────────

    @staticmethod
    def _to_big_amount(
        value: Decimal,
        decimals: int,
        symbol: str,
    ) -> common_pb2.BigAmount:
        """
        Python Decimal → Protobuf BigAmount（string 格式）。
        确保精度不丢失：Decimal → int → str，全程无浮点数。
        """
        raw_int = int(value * (10 ** decimals))
        return common_pb2.BigAmount(
            raw_value=str(raw_int),
            decimals=decimals,
            symbol=symbol,
        )

    # ── 交易执行 ────────────────────────────────────────────────────────

    def execute_swap(
        self,
        protocol_id: str,
        payload: bytes,          # 由对应 Adapter 序列化的协议参数（见 §3.2）
        slippage_bps: int,       # 最大允许滑点（万分位），不超过 invariant_max_slippage_bps
        gas_price_limit: Decimal,
        is_shadow: bool = False,
    ) -> Optional[trading_pb2.TradeResponse]:
        """
        提交 Swap 决策。is_shadow=True 时走 ShadowTrade RPC，不产生真实签名。
        """
        if not self._check_local_watermark():
            return None  # 本地水位线未就绪，放弃本次决策

        request = trading_pb2.TradeRequest(
            ctx=self._build_context(),
            protocol_id=protocol_id,
            action=trading_pb2.TradeAction.SWAP,
            payload=payload,
            max_slippage_bps=str(slippage_bps),
            gas_price_limit=str(int(gas_price_limit * 10**9)),  # 转换为 Gwei 整数字符串
        )

        try:
            if is_shadow:
                response = self.stub.ShadowTrade(request, timeout=10.0)
            else:
                response = self.stub.ExecuteTrade(request, timeout=10.0)
            return response

        except grpc.RpcError as e:
            # 区分不同错误类型，便于上层策略决策
            if "StaleDataError" in e.details():
                # Go 端 Sync Sentinel 拦截：本地水位线已滞后，等待下一个区块事件
                self._on_stale_data(e.details())
            elif "SimulationError" in e.details():
                # 仿真失败：策略逻辑问题，记录日志
                self._on_simulation_error(e.details())
            else:
                self._on_unknown_error(e)
            return None

    def _on_stale_data(self, detail: str) -> None:
        """水位线滞后回调，子类可覆盖实现自定义处理逻辑"""
        pass  # 默认：静默放弃，等待下一个链上事件更新水位线

    def _on_simulation_error(self, detail: str) -> None:
        """仿真失败回调，子类可覆盖"""
        pass

    def _on_unknown_error(self, error: grpc.RpcError) -> None:
        """未知错误回调，子类可覆盖"""
        pass

    # ── 心跳查询 ────────────────────────────────────────────────────────

    def sync_system_status(self) -> Optional[trading_pb2.SystemStatus]:
        """
        主动查询 Go 端当前水位线（GetSystemStatus RPC）。
        Agent 启动时或长时间无数据时调用，确保本地状态与 Go 端对齐。
        """
        try:
            status = self.stub.GetSystemStatus(trading_pb2.Empty(), timeout=5.0)
            if status.is_healthy:
                # 用 Go 端最新块高校正本地水位线（防止 Redis 积压导致本地水位线滞后）
                self.last_seen_block = max(self.last_seen_block, status.current_block)
            return status
        except grpc.RpcError:
            return None

    # ── 抽象接口 ────────────────────────────────────────────────────────

    @abstractmethod
    def evaluate_strategy(self, event: common_pb2.ChainEvent) -> None:
        """
        策略推理入口，由子类实现。
        每收到一个新区块事件时调用。
        """
        raise NotImplementedError
```

### 3.2 精度分工原则

Python 端与 Go 端在数学计算上有严格的职责边界：

| 职责 | Python Agent（Zone A） | Go 执行引擎（Zone B） |
|---|---|---|
| **决策逻辑** | ✅ "如果价格低于 X 则买入" | ❌ 不做业务判断 |
| **金额计算** | `Decimal` 计算，转 `str` 传输 | `big.Int` 接收，EVM 级精度运算 |
| **链上数学** | ❌ 不做 tick/slot0 计算 | ✅ Adapter 执行 Calldata 编码 |
| **水位线校验** | 辅助（本地 `last_seen_block`） | 硬拦截（Sync Sentinel） |
| **签名** | ❌ 不持有任何密钥 | Zone C MPC 签名 |

### 3.3 影子模式切换

通过 `is_shadow=True`，策略可在不修改任何推理逻辑的情况下切换执行模式：

```python
# 策略子类示例
class ArbitrageStrategy(BaseStrategyAgent):

    def evaluate_strategy(self, event: ChainEvent):
        if self._detect_arb_opportunity(event):
            # SHADOWED 阶段：is_shadow=True，Go 端跑完验证但不签名
            # LIVE 阶段：is_shadow=False，走完整执行路径
            self.execute_swap(
                protocol_id="UNISWAP_V3_ETH",
                payload=self._encode_payload(event),
                slippage_bps=30,
                gas_price_limit=Decimal("50"),  # 50 Gwei
                is_shadow=(self.strategy_state != "LIVE"),
            )
```

---

## 4. 水位线联动全景

```
Zone A（Python Agent）                  Zone B（Go Sync Sentinel）
──────────────────────────────          ──────────────────────────────────────
Redis Stream 推送 ChainEvent
    └── event.block_number = 19238415
    └── on_chain_event() 更新
        last_seen_block = 19238415
                │
                │ gRPC TradeRequest
                │ ctx.last_sync_block = 19238415
                ▼
                                        CheckWatermark()
                                            current_block = 19238420
                                            lag = 19238420 - 19238415 = 5
                                            max_lag = 2（watermark_max_lag 默认值）
                                            ──────────────────────────────
                                            lag(5) > max_lag(2)
                                            → 返回 StaleDataError
                │
                │ TradeResponse { error_message: "StaleDataError: lag=5" }
                ▼
            _on_stale_data() 回调
            等待下一个 ChainEvent 更新水位线
```

---

## 5. 评价标准

| 维度 | 好架构 | 坏架构 |
|---|---|---|
| **拦截物理性** | Zone B 的 Sync Sentinel 强制硬拦截，不可被策略代码绕过 | 仅依赖 Agent 自身校验水位，代码被黑或 Bug 时会基于过期数据发单 |
| **网络开销** | Agent 提供主动心跳与本地辅助拦截，避免无效的 gRPC往返 | Agent 盲目发单，导致 RPC 抖动时 Zone B 被请求打爆 |
| **精度保护** | 金额在跨语言边界（Python → Go）前强制转化为 Decimal 和 String | Python 端存在 float 计算，导致最终发到链上的 Wei 数值有微小偏差 |

---

*上一篇：[2.4 历史数据归档](../02_数据总线与契约/2.4_历史数据归档.md) | 下一篇：[3.2 验证层](./3.2_验证层_EVM仿真与三源预言机.md)*
