# 3.2 验证层：EVM 仿真与三源预言机 (Validation Layer)

> **文档类型：** 架构文档 · 核心执行引擎篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.1 策略 Agent 与水位线拦截](./3.1_策略Agent与水位线拦截.md)
> **下游文档：** [3.3 幂等状态机 FSM](./3.3_幂等状态机FSM.md) · [7.2 G1-G8 门控实现细节](../07_验证与回测/7.2_G1-G8门控实现细节.md)
>
> **合并说明：** 本文档由以下旧文档合并而来：
> - `模块_2_硬核验证与沙盒防线.md`（三源预言机、不变性断言、Fuzzing 概述）
> - `Go_模块_基于_StateDB_的轻量仿真器原型实现.md`（EVM 仿真器详细实现）
> - `模块_1_策略大脑与协议适配.md` §1.1（EVM 数学库与计算对称性设计）

---

## 1. 验证层职责概述

验证层在 Sync Sentinel 水位线通过后、FSM 状态推进至 SIGNED 之前执行，包含三道串行校验：

```
TradeRequest 通过 Sync Sentinel
         │
         ▼
┌─────────────────────────────────────┐
│  校验一：三源预言机交叉校验            │  → 防止价格操纵 / 闪电贷攻击
│  Triple-Oracle Guard                │
└──────────────────┬──────────────────┘
                   │ 价格有效
                   ▼
┌─────────────────────────────────────┐
│  校验二：EVM 仿真执行                 │  → 消除回测陷阱，位级精度对齐
│  StateDB Simulator                  │
└──────────────────┬──────────────────┘
                   │ 仿真成功
                   ▼
┌─────────────────────────────────────┐
│  校验三：不变性断言                   │  → 物理底线防护，单次执行不得破线
│  InvariantChecker                   │
└──────────────────┬──────────────────┘
                   │ 全部通过
                   ▼
         FSM 推进至 SIMULATED（§3.3）
```

任意一道校验失败，请求在本层终止，FSM 状态置为 `FAILED`，不进入签名流程。

---

## 2. 校验一：三源预言机交叉校验（Triple-Oracle Guard）

### 2.1 设计原理

单一价格源可被闪电贷瞬间操纵（DEX Slot0 尤其脆弱）。系统强制聚合三个独立来源的价格，任意两源偏差超过阈值则本次决策熔断：

| 价格源 | 获取方式 | 抗操纵性 | 实时性 |
|---|---|---|---|
| **Chainlink** | 链上 `latestRoundData()` | ⭐⭐⭐ 最强（去中心化喂价网络） | 低（约 1 小时或偏差 0.5% 触发更新） |
| **Uniswap TWAP** | 观察区间 = 最近 30 分钟 | ⭐⭐ 强（抗闪电贷，但对快速变化响应慢） | 中（每个区块重新计算） |
| **DEX Slot0** | `slot0()` 直接读取当前价格 | ⭐ 弱（最实时但可被单笔大 Swap 瞬间扭曲） | 高（每笔 Swap 后更新） |
| **中位价（决策用）** | 三源的中位数 | — | 以最慢的源为准 |

**熔断公式：**

$$\max(|P_1 - P_2|,\ |P_2 - P_3|,\ |P_1 - P_3|) > \Delta_{oracle}$$

其中 $\Delta_{oracle}$ 对应配置键 `oracle_max_deviation_bps`（默认值见 README §0.6）。

### 2.2 Go 实现

```go
// oracle_guard.go
type OracleGuard struct {
    maxDeviationBps uint64 // 对应配置键: oracle_max_deviation_bps（默认值见 README §0.6）
    chainlink       ChainlinkClient
    uniswapTWAP     UniswapTWAPClient
    dexSlot0        DEXSlot0Client
}

// ValidateAndGetMedian 校验三源价格并返回中位价
// 返回值：中位价（big.Int），用于后续仿真和不变性断言
func (g *OracleGuard) ValidateAndGetMedian(
    ctx context.Context,
    tokenPair string,
    atBlock uint64,
) (*big.Int, error) {
    // 1. 并发获取三源价格
    p1, err1 := g.chainlink.GetPrice(ctx, tokenPair, atBlock)
    p2, err2 := g.uniswapTWAP.GetPrice(ctx, tokenPair, atBlock)
    p3, err3 := g.dexSlot0.GetPrice(ctx, tokenPair, atBlock)

    // 任一源不可用时，降级为两源校验（Chainlink 和 TWAP 为可信源）
    if err3 != nil {
        // DEX Slot0 不可用：告警但不熔断，用 Chainlink + TWAP 两源校验
        g.logger.Warn("DEX Slot0 unavailable, fallback to 2-source validation",
            zap.String("pair", tokenPair), zap.Error(err3))
        return g.validateTwoSource(p1, p2)
    }
    if err1 != nil || err2 != nil {
        // Chainlink 或 TWAP 不可用：直接拒绝，单点故障不可接受
        return nil, fmt.Errorf("ORACLE_UNAVAILABLE: critical source failure")
    }

    // 2. 计算两两偏差（万分位）
    diff12 := calcDeviationBps(p1, p2)
    diff23 := calcDeviationBps(p2, p3)
    diff13 := calcDeviationBps(p1, p3)
    maxDiff := maxOf(diff12, diff23, diff13)

    // 3. 熔断判断
    if maxDiff > g.maxDeviationBps {
        return nil, fmt.Errorf(
            "PRICE_ORACLE_SKEW: max deviation %d bps exceeds threshold %d bps "+
                "(P_chainlink=%s, P_twap=%s, P_slot0=%s)",
            maxDiff, g.maxDeviationBps,
            p1.String(), p2.String(), p3.String(),
        )
    }

    // 4. 返回三源中位价作为决策价格
    return medianOf(p1, p2, p3), nil
}

// calcDeviationBps 计算两价格偏差（万分位，使用 big.Int 保证精度）
func calcDeviationBps(a, b *big.Int) uint64 {
    diff := new(big.Int).Sub(a, b)
    diff.Abs(diff)
    // deviation = |a - b| * 10000 / a
    result := new(big.Int).Mul(diff, big.NewInt(10000))
    result.Div(result, a)
    return result.Uint64()
}
```

### 2.3 价格数据新鲜度校验

三源价格在进入熔断逻辑前，还需通过新鲜度校验：

```go
// 价格新鲜度校验（在 ValidateAndGetMedian 内部调用）
func (g *OracleGuard) checkFreshness(price *PriceData) error {
    age := time.Now().Unix() - price.Timestamp
    if age > int64(g.priceStaleThresholdSec) { // 对应配置键: price_stale_threshold_sec
        return fmt.Errorf("PRICE_STALE: %s price is %ds old (threshold: %ds)",
            price.Source, age, g.priceStaleThresholdSec)
    }
    return nil
}
```

---

## 3. 校验二：EVM 仿真执行（StateDB Simulator）

### 3.1 计算对称性设计

**回测陷阱的根源：** Python 使用浮点数计算，Solidity 使用整数除法，两者存在系统性偏差。例如：
- Python: `0.1 + 0.2 = 0.30000000000000004`
- Solidity: `1000 * 10**18 / 3 = 333333333333333333`（向下取整）

**解决方案：** 在 Go 中使用 `math/big` + `go-ethereum/core/vm`，所有计算与以太坊主网节点完全一致：

```
Python 决策层         Proto 传输        Go 仿真层               链上 Solidity
──────────────        ─────────         ─────────────────       ─────────────
Decimal("1e18") →→→  str "1000...0" →→→ big.Int(1e18)     ≡≡≡  uint256(1e18)
                                         math/big 运算            整数运算
                                         go-ethereum 常量          完全一致
```

### 3.2 仿真器核心实现

```go
// simulator.go
type Simulator struct {
    chainConfig *params.ChainConfig // 目标链的 EIP 配置
    stateDB     *state.StateDB      // 内存态账户状态缓存
    rpc         RPCClient           // 用于按需补全 StateDB 中缺失的账户状态
    logger      *zap.Logger
}

// Execute 是仿真执行入口，由验证层在三源预言机校验通过后调用
func (s *Simulator) Execute(
    ctx context.Context,
    req *proto.TradeRequest,
    medianPrice *big.Int, // 来自三源预言机的中位价
) (*SimulationResult, error) {

    // 1. 快照当前 StateDB（执行完断言后回滚，不污染下次仿真）
    snapID := s.stateDB.Snapshot()
    defer s.stateDB.RevertToSnapshot(snapID)

    // 2. 构造区块环境（使用 Agent 上报的水位线区块，确保精度一致）
    blockCtx := vm.BlockContext{
        CanTransfer: core.CanTransfer,
        Transfer:    core.Transfer,
        GetHash:     s.getBlockHash,
        BlockNumber: new(big.Int).SetUint64(req.Ctx.LastSyncBlock),
        Time:        uint64(time.Now().Unix()),
        GasLimit:    30_000_000,
        BaseFee:     s.getCurrentBaseFee(ctx),
    }

    // 3. 构造交易上下文
    txCtx := vm.TxContext{
        Origin:   common.HexToAddress(req.Ctx.AgentId), // Agent 地址
        GasPrice: s.parseGasPrice(req.GasPriceLimit),
    }

    // 4. 初始化原生 go-ethereum EVM（直接使用链上字节码执行环境）
    evm := vm.NewEVM(blockCtx, txCtx, s.stateDB, s.chainConfig, vm.Config{})

    // 5. 执行合约调用（链下精度 = 链上精度，误差 = 0）
    callData, err := s.decodePayload(req.ProtocolId, req.Payload)
    if err != nil {
        return nil, fmt.Errorf("SimulationError: payload decode failed: %v", err)
    }

    preState := s.captureAccountState()

    ret, gasLeft, err := evm.Call(
        vm.AccountRef(txCtx.Origin),
        common.HexToAddress(callData.To),
        callData.Data,
        req.GasLimit,
        callData.Value,
    )
    if err != nil {
        return nil, fmt.Errorf("SimulationError: EVM execution reverted: %v", err)
    }

    postState := s.captureAccountState()

    // 6. 不变性断言（见 §4）
    if err := s.invariants.Check(preState, postState, req, medianPrice); err != nil {
        return nil, err // INVARIANT_BROKEN: ...
    }

    gasUsed := req.GasLimit - gasLeft
    return &SimulationResult{
        ReturnData: ret,
        GasUsed:    gasUsed,
        PreState:   preState,
        PostState:  postState,
    }, nil
}
```

### 3.3 StateDB 内存缓存维护

```go
// 按需从 RPC 补全 StateDB 中缺失的账户状态（懒加载）
func (s *Simulator) ensureAccountLoaded(addr common.Address) error {
    if s.stateDB.Exist(addr) {
        return nil // 已在缓存中
    }
    // 从 RPC 获取账户状态并写入 StateDB
    balance, _ := s.rpc.BalanceAt(context.Background(), addr, nil)
    nonce, _   := s.rpc.NonceAt(context.Background(), addr, nil)
    code, _    := s.rpc.CodeAt(context.Background(), addr, nil)

    s.stateDB.CreateAccount(addr)
    s.stateDB.SetBalance(addr, balance)
    s.stateDB.SetNonce(addr, nonce)
    s.stateDB.SetCode(addr, code)
    return nil
}
```

**LRU 缓存策略：** StateDB 使用 LRU 缓存常用合约状态（如 USDC、常见 DEX 池），单次仿真时间通常控制在 **10–50ms**，满足 P99 < 500ms 的端到端延迟目标。

---

## 4. 校验三：不变性断言（InvariantChecker）

### 4.1 设计原理

不变性断言是策略开发者在 `BaseStrategy.invariants` 中声明的**物理底线约束**，在每次仿真执行后强制验证。系统内置三条全局断言，策略可额外声明自定义断言：

| 断言类型 | 说明 | 配置键 | 违反时动作 |
|---|---|---|---|
| **最大回撤** | 单次执行后 U 本位净值跌幅不超过阈值 | `invariant_max_drawdown_bps` | `INVARIANT_BROKEN`，FSM → FAILED |
| **最大滑点** | 实际执行价与仿真预期价偏差不超过阈值 | `invariant_max_slippage_bps` | `INVARIANT_BROKEN`，FSM → FAILED |
| **Gas 倍数** | 实际 Gas 不超过估算值的倍数 | `invariant_max_gas_multiple` | `INVARIANT_BROKEN`，FSM → FAILED |
| **代币非归零** | 执行后策略持有的主要代币不为零 | — （内置，不可配置） | `INVARIANT_BROKEN`，FSM → FAILED |

### 4.2 Go 实现

```go
// invariant_checker.go
type InvariantChecker struct {
    maxDrawdownBps  uint64  // 对应配置键: invariant_max_drawdown_bps（默认值见 README §0.6）
    maxSlippageBps  uint64  // 对应配置键: invariant_max_slippage_bps
    maxGasMultiple  uint64  // 对应配置键: invariant_max_gas_multiple（如 300 = 3x）
}

// Check 在 EVM 仿真执行后调用
func (c *InvariantChecker) Check(
    pre, post *AccountState,
    req *proto.TradeRequest,
    medianPrice *big.Int,
    simResult *SimulationResult,
) error {
    // ── 断言一：U 本位净值最大回撤 ────────────────────────────────────
    preValueUSD  := c.toUSD(pre.TotalBalance, medianPrice)
    postValueUSD := c.toUSD(post.TotalBalance, medianPrice)

    if preValueUSD.Sign() > 0 {
        // drawdown = (pre - post) * 10000 / pre （万分位）
        diff := new(big.Int).Sub(preValueUSD, postValueUSD)
        if diff.Sign() > 0 {
            drawdownBps := new(big.Int).Mul(diff, big.NewInt(10000))
            drawdownBps.Div(drawdownBps, preValueUSD)
            if drawdownBps.Uint64() > c.maxDrawdownBps {
                return fmt.Errorf(
                    "INVARIANT_BROKEN: drawdown %d bps exceeds limit %d bps",
                    drawdownBps.Uint64(), c.maxDrawdownBps,
                )
            }
        }
    }

    // ── 断言二：Gas 倍数上限 ───────────────────────────────────────────
    estimatedGas := req.GasLimit
    if estimatedGas > 0 && simResult.GasUsed > 0 {
        // multiple = actual * 100 / estimated（百分比，300 = 3x）
        multiple := simResult.GasUsed * 100 / estimatedGas
        if multiple > c.maxGasMultiple {
            return fmt.Errorf(
                "INVARIANT_BROKEN: gas usage %dx exceeds limit %dx",
                multiple/100, c.maxGasMultiple/100,
            )
        }
    }

    // ── 断言三：代币非预期归零 ─────────────────────────────────────────
    for token, preBal := range pre.TokenBalances {
        postBal := post.TokenBalances[token]
        if preBal.Sign() > 0 && postBal.Sign() == 0 {
            return fmt.Errorf(
                "INVARIANT_BROKEN: unexpected token depletion for %s", token,
            )
        }
    }

    return nil
}
```

---

## 5. G4 Fuzzing 与影子模式（概述）

> 详细实现见 §7.2 G1-G8 门控实现细节。本节仅描述与验证层的接口关系。

### 5.1 G4 极端 Fuzzing

G4 Fuzzing 使用 Anvil Fork Node（Zone B，见 §1.2）在主网分叉环境中注入极端参数：

- Gas 价格飙升 1000 倍
- 池子流动性骤降 90%
- 区块时间戳跳变

Fuzzing 与本验证层共享同一个 `Simulator` 和 `InvariantChecker`，区别在于 `SimulationRequest` 中注入的是随机极端参数而非真实市场参数。策略必须在 **1000 轮** Fuzzing 中全部通过不变性断言，才能推进至 G5 回测阶段。

### 5.2 G7 影子模式

影子模式（`ShadowTrade` RPC）在 Zone B 走完本验证层的全部三道校验，但在 FSM 推进至 SIGNED 阶段前物理截断，不发送签名请求至 Zone C。

仿真结果（预期收益、Gas 成本、价格偏差）写入专用表供 G7 对比分析使用（见 §7.2）。

---

## 6. 错误分类与上游响应

| 错误码 | 触发原因 | FSM 终态 | Python Agent 处理建议 |
|---|---|---|---|
| `ORACLE_UNAVAILABLE` | Chainlink / TWAP 不可用 | FAILED | 等待下个区块重试（非策略问题） |
| `PRICE_ORACLE_SKEW` | 三源价格偏差超阈值 | FAILED | 等待价格稳定后重试 |
| `PRICE_STALE` | 价格数据过期 | FAILED | 等待数据更新后重试 |
| `SimulationError` | EVM 仿真 Revert | FAILED | 检查策略参数（滑点、Gas 限制） |
| `INVARIANT_BROKEN` | 不变性断言破线 | FAILED | 策略参数超出安全边界，需人工审查 |

---

*上一篇：[3.1 策略 Agent 与水位线拦截](./3.1_策略Agent与水位线拦截.md) | 下一篇：[3.3 幂等状态机 FSM](./3.3_幂等状态机FSM.md)*
