# 7.2 验证门控 G1-G8 对齐 (Validation Gates G1-G8 Alignment)

> **文档类型：** 架构文档 · 验证与回测篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.2 验证层：EVM 仿真与三源预言机](../03_核心执行引擎/3.2_验证层_EVM仿真与三源预言机.md) · [7.1 回测引擎与数据接口](./7.1_回测引擎与数据接口.md)
> **下游文档：** [8.1 Go 仿真器参考实现](../08_参考实现/8.1_Go仿真器参考实现.md) · [8.2 Python Agent 基类参考实现](../08_参考实现/8.2_Python_Agent基类参考实现.md)
>
> **来源文档：** `模块_9_验证门控_G1-G8.md`（旧实现文档，G3/G5/G6/G7 编号错误）；PRD `验证门控标准说明文档`（权威编号来源）
>
> ---
> ### ⚠️ 重要修正说明（G1-G8 编号对齐）
>
> 旧架构文档 `模块_9_验证门控_G1-G8.md` 的门控编号与 PRD 存在**完全错位**，本文档以 PRD 为唯一权威来源重新定义全部 8 个门控。
>
> | 门控 | 旧文档（错误）| PRD（正确）| 冲突说明 |
> |---|---|---|---|
> | G3 | 回测（Backtest）| **不变性断言（Invariant Assertions）** | 旧文档将 G3 定义为 G5 的内容 |
> | G5 | 毒性流审计（Toxic Flow Audit）| **回测（Backtest）** | 毒性流审计是事后审计，非事前门控 |
> | G6 | 影子模式（Shadow Mode）| **蒙特卡洛（Monte Carlo）** | 旧文档将 G6 与 G7 对调 |
> | G7 | 未定义 / 遗漏 | **影子模式（Shadow Mode ≥ 72h）** | 旧文档缺失 G7 |
>
> 所有引用 G3/G5/G6/G7 的代码、注释、配置文件均须按本文档完成重编号。

---

## 1. 门控全景：G1-G8 正确编号

```
策略生命周期          DRAFT ──────────────────────────────────────────▶ LIVE
                          │                                              │
                          ▼                                              │
                    ┌─────────────────────────────────────────────────┐ │
安全门控（G1-G4）    │  G1 静态分析  G2 EVM仿真  G3 不变性断言  G4 模糊测试│ │
（DRAFT→VALIDATED） └─────────────────────────────────────────────────┘ │
                          │ 通过 → 状态: VALIDATED                       │
                          ▼                                              │
                    ┌──────────────────────────────────────────────────┐│
性能门控（G5-G6）    │          G5 历史回测          G6 蒙特卡洛         ││
（VALIDATED→EVALUATED）└──────────────────────────────────────────────┘│
                          │ 通过 → 状态: EVALUATED                       │
                          ▼                                              │
                    ┌──────────────────────────────────────────────────┐│
生产门控（G7-G8）    │     G7 影子模式(≥72h)       G8 灰度验证(≥7d)      ││
（EVALUATED→LIVE）   └──────────────────────────────────────────────────┘│
                          │ 通过 → 状态: LIVE ─────────────────────────▶─┘
```

---

## 2. 安全门控组（G1-G4）：DRAFT → VALIDATED

安全门控的目标是在策略使用任何真实资金之前，从代码静态安全到链上运行时行为，进行全面的安全扫描。**G1-G4 任一未通过，策略不得推进至 VALIDATED 状态。**

### G1 — 静态代码分析（Static Analysis）

**职责：** 在不执行代码的情况下，扫描策略代码中的已知安全风险模式。

| 检查项 | 方法 | 通过标准 |
|---|---|---|
| 禁止直接 RPC 调用 | AST 分析，检查 `web3.eth.*` / `requests.get(rpc)` 等调用 | 零直接 RPC 调用 |
| 禁止明文私钥 | 正则扫描，检查 `private_key =` / `0x` 开头的 64 字节十六进制串 | 零私钥明文 |
| 禁止不安全随机数 | 检查 `random.random()` 在策略执行关键路径中的使用 | 关键路径零不安全随机数 |
| `Decimal` 精度合规 | 检查是否存在 `float()` 对金额的直接转换 | 金额计算零 float 使用 |
| 依赖版本锁定 | 检查 `requirements.txt` 是否所有依赖均锁定至确定版本 | 全部锁定，无 `>=` 范围约束 |

```python
# G1 实现骨架
class G1StaticAnalyzer:
    def run(self, strategy_code_path: str) -> G1Result:
        tree = ast.parse(open(strategy_code_path).read())
        violations = []

        # 检查直接 RPC 调用
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if self._is_rpc_call(node):
                    violations.append(Violation("DIRECT_RPC_CALL", node.lineno))

        return G1Result(passed=len(violations) == 0, violations=violations)
```

---

### G2 — EVM 仿真精度校验（EVM Simulation）

**职责：** 在 Anvil 主网分叉上执行完整 EVM 仿真，验证交易在真实链上状态下不会 Revert，并校验仿真结果与策略预期的精度偏差。

| 检查项 | 通过标准 | 详细实现文档 |
|---|---|---|
| 交易不 Revert | 仿真执行成功（`status == 1`） | §3.2 §8.1 |
| Gas 估算误差 | 实际 Gas ≤ 估算 Gas × 1.1（10% 容差）| §3.2 |
| 输出金额偏差 | 实际 `amount_out` 与预期偏差 ≤ `max_slippage_bps` | §3.2 |
| 预言机价格校验 | 三源中位价偏差 ≤ 50 bps，否则拒绝本次仿真 | §3.2 |

**性能要求：** 单次 EVM 仿真耗时 **10–50ms**（依赖 StateDB 内存缓存命中率，见 §8.1）。

---

### G3 — 不变性断言（Invariant Assertions）

**职责：** 在 EVM 仿真结果上运行**业务级不变性断言**，确保交易不会将策略仓位推入违反物理底线的状态。

> **与 G2 的区别：** G2 检查"交易能否执行"（技术层面不 Revert），G3 检查"执行后是否符合业务约束"（语义层面不违反风控底线）。一笔交易完全可以技术上成功但语义上违反不变性（例如：Swap 成功，但导致单一仓位占比超过 80%）。

**核心不变性断言集合（来自 PRD 验证门控标准 §3）：**

```go
// invariant_assertions.go

type InvariantChecker struct {
    cfg InvariantConfig
}

func (c *InvariantChecker) Check(
    preState  *PortfolioState,
    postState *PortfolioState,
    simResult *SimulationResult,
) []InvariantViolation {
    var violations []InvariantViolation

    // 断言 1：单笔仿真损失不超过 1%
    // 防止单笔交易因参数设置失误导致巨额损失
    if loss := calcLossPct(preState.NAV, postState.NAV); loss > 0.01 {
        violations = append(violations, InvariantViolation{
            Name:    "SINGLE_LOSS_LIMIT",
            Message: fmt.Sprintf("single trade loss %.2f%% > 1%% limit", loss*100),
        })
    }

    // 断言 2：单一代币敞口不超过组合 NAV 的 50%
    for token, balance := range postState.Balances {
        tokenValueUSD := calcTokenValue(token, balance)
        exposurePct := tokenValueUSD / postState.NAV
        if exposurePct > 0.50 {
            violations = append(violations, InvariantViolation{
                Name:    "SINGLE_ASSET_CONCENTRATION",
                Message: fmt.Sprintf("token %s exposure %.1f%% > 50%% limit", token, exposurePct*100),
            })
        }
    }

    // 断言 3：交易后剩余 Gas 储备不低于 0.05 ETH
    // 防止 Gas 耗尽导致后续无法执行紧急操作
    if postState.ETHBalance < Decimal("0.05") {
        violations = append(violations, InvariantViolation{
            Name:    "GAS_RESERVE_DEPLETED",
            Message: fmt.Sprintf("ETH balance %.4f < 0.05 ETH minimum reserve", postState.ETHBalance),
        })
    }

    // 断言 4：策略总 NAV 不低于初始资本的 80%（10% 回撤硬底线）
    // 这是 G3 的保守底线，G5/G6 会进一步评估回撤特征
    if drawdown := 1 - postState.NAV/c.cfg.InitialCapital; drawdown > 0.10 {
        violations = append(violations, InvariantViolation{
            Name:    "NAV_FLOOR_BREACH",
            Message: fmt.Sprintf("NAV drawdown %.1f%% > 10%% hard floor", drawdown*100),
        })
    }

    return violations
}
```

**通过标准：** 零不变性断言违规。任何违规直接拒绝交易，FSM 不推进。

---

### G4 — 模糊测试（Fuzzing）

**职责：** 对策略关键逻辑进行 **1000 轮随机参数输入**的模糊测试，验证策略在极端参数下不会崩溃或产生不可预期的行为。

**测试范围：**

| 测试维度 | 随机范围 | 目的 |
|---|---|---|
| Gas 价格 | 1 – 1000 Gwei | 测试极低/极高 Gas 下的拒绝逻辑 |
| 交易规模 | $1 – $10,000,000 | 测试规模边界的精度和不变性 |
| 池流动性 | 正常的 1% – 200% | 测试流动性枯竭场景 |
| 价格波动 | -50% – +100% | 测试价格跳变下的保护机制 |
| 数据水位线延迟 | 0 – 100 个区块 | 测试 Sync Sentinel 的拦截准确性 |

```go
// G4 模糊测试执行器
func (g *G4FuzzRunner) Run(agent BaseAgent, rounds int) G4Result {
    passed, failed := 0, 0
    violations := []FuzzViolation{}

    for i := 0; i < rounds; i++ {
        params := g.randParams()

        // 在 Anvil 隔离环境中执行（Snapshot/Revert 隔离，见 §8.1）
        anvil := g.anvil.Snapshot()
        result := g.executeInIsolation(agent, params, anvil)
        anvil.Revert()  // 每轮测试后恢复状态，不污染下一轮

        if result.HasPanic || result.InvariantBroken {
            failed++
            violations = append(violations, FuzzViolation{Round: i, Params: params, Error: result.Error})
        } else {
            passed++
        }
    }

    return G4Result{
        TotalRounds: rounds,
        PassedRounds: passed,
        FailedRounds: failed,
        Violations: violations,
        Passed: failed == 0,   // 零失败才算通过
    }
}
```

**通过标准：** 1000 轮测试零崩溃、零不变性断言违规。

---

## 3. 性能门控组（G5-G6）：VALIDATED → EVALUATED

### G5 — 历史回测（Historical Backtest）

**职责：** 在至少 90 天的历史数据上运行完整回测（实现见 §7.1），验证策略的历史盈利能力和风险特征。

**门控标准（来自 PRD 评估指标体系 §5，按指标层级分组）：**

| 层级 | 指标 | 标准 | 不达标后果 |
|---|---|---|---|
| **L1 否决** | Sharpe Ratio | ≥ 1.0 | 直接 FAIL，无需看其他指标 |
| **L2 硬门槛** | 最大回撤（MDD） | ≤ 20% | 不达标则 FAIL |
| **L3 主要指标** | 年化收益率 | ≥ 10% | 不达标则 FAIL |
| **L3 主要指标** | 资金利用率 | ≥ 40% | 不达标则 FAIL |
| **L4 成本指标** | Gas 成本占比 | ≤ 30% | 不达标则 FAIL |
| **L5 参考** | 无常损失 | 参考记录，不设硬底线 | 写入报告供人工参考 |

**回测时间范围要求：**
- 最短 90 天（约 648,000 个 ETH 区块）
- 须覆盖至少一次市场波动率显著变化的区间（牛市 + 熊市段各至少 20%）

---

### G6 — 蒙特卡洛压力测试（Monte Carlo）

**职责：** 基于历史回测数据，生成 **5000 轮随机扰动路径**，检验策略的稳健性（实现见 §7.1 §5）。

**门控标准（来自 PRD §6）：**

| 指标 | 标准 | 说明 |
|---|---|---|
| 正收益路径占比 | ≥ 60%（5000 轮中 ≥ 3000 轮正收益） | L2 硬门槛 |
| P5 极端情景收益 | ≥ -30%（不超过 30% 损失） | L2 尾风险控制 |
| 中位数收益 | ≥ 5%（年化） | L3 主要指标 |

---

## 4. 生产门控组（G7-G8）：EVALUATED → LIVE

### G7 — 影子模式（Shadow Mode ≥ 72 小时）

**职责：** 策略运行完整的实盘决策和验证流程，但在 FSM 的 `SIGNED` 阶段前物理截断，不发生真实签名和链上广播。同时记录策略的"假设 PnL"与真实市场走势进行对比。

**技术实现：** Python Agent 的 `is_shadow=True` 参数（见 §8.2），gRPC 使用 `ShadowTrade` 而非 `ExecuteTrade`（见 §2.1）。

**通过标准：**

| 条件 | 要求 | 来源 |
|---|---|---|
| 运行时长 | ≥ 72 小时连续运行 | PRD §7 |
| 假设 PnL 收益性 | 72 小时假设 PnL > 0（正收益） | PRD §7 |
| 异常率 | `StaleDataError` / `SIMULATION_REVERT` 出现率 < 5% | 系统稳定性要求 |
| 治理环境准入 | 依赖协议无 HIGH_RISK / SUSPENDED 状态（§5.2 G7 联动） | §5.2 §7.2 |
| 手动审批 | G7 通过后须管理员链下确认，签字后方可推进 STAGED | PRD §3.5 |

---

### G8 — 灰度验证（Staged Validation ≥ 7 天）

**职责：** 策略以真实资金（仓位上限：全局资金池的 5%）运行至少 7 天，进行生产环境的真实性能验证。

**技术实现：** FSM 状态为 `STAGED`，大额审批使用绝对金额阈值（$10,000，见 §5.1 §3.1）。

**通过标准：**

| 条件 | 要求 | 来源 |
|---|---|---|
| 运行时长 | ≥ 7 天真实资金运行 | PRD §8 |
| 真实 Sharpe | 7 天年化 Sharpe ≥ 0.5（宽松版，允许短期波动）| PRD §8 |
| 对账通过率 | 账实对账差异为零 | §4.1 |
| 资金上限合规 | 单策略仓位 ≤ 全局池 5% | PRD §3.5 |
| 手动审批 | G8 通过后须管理员链下最终确认，LIVE 阈值切换为相对比例（15%）| §5.1 §3.2 |

---

## 5. 门控执行顺序与阻断逻辑

```python
class ValidationGateRunner:
    """按顺序执行 G1-G8，前置门控失败时阻断后续"""

    def run_safety_gates(self, strategy) -> GateResult:
        """安全门控 G1-G4（DRAFT → VALIDATED）"""
        for gate in [G1StaticAnalyzer(), G2EVMSimulator(), G3InvariantChecker(), G4FuzzRunner()]:
            result = gate.run(strategy)
            if not result.passed:
                return GateResult(passed=False, blocked_at=gate.name, details=result)
        return GateResult(passed=True)

    def run_performance_gates(self, strategy) -> GateResult:
        """性能门控 G5-G6（VALIDATED → EVALUATED）"""
        # G5 先跑，G6 依赖 G5 的回测数据作为基线
        g5 = G5BacktestEngine().run(strategy)
        if not g5.passed:
            return GateResult(passed=False, blocked_at="G5", details=g5)

        g6 = G6MonteCarloEngine().run(strategy, base_backtest=g5)
        if not g6.passed:
            return GateResult(passed=False, blocked_at="G6", details=g6)

        return GateResult(passed=True)

    def run_production_gates(self, strategy) -> GateResult:
        """生产门控 G7-G8（EVALUATED → LIVE，需要人工审批）"""
        # G7 运行期间，系统持续检查治理哨兵状态
        g7 = G7ShadowRunner().run(strategy, min_hours=72)
        if not g7.passed:
            return GateResult(passed=False, blocked_at="G7", details=g7)
        # G7 通过后必须等待管理员手动确认，才能推进 STAGED
        self.require_manual_approval("G7_PASSED", strategy.id)

        g8 = G8StagedRunner().run(strategy, min_days=7)
        if not g8.passed:
            return GateResult(passed=False, blocked_at="G8", details=g8)
        # G8 通过后必须等待管理员最终确认，才能推进 LIVE
        self.require_manual_approval("G8_PASSED", strategy.id)

        return GateResult(passed=True)
```

---

## 6. 各门控与其他模块的依赖关系

| 门控 | 依赖组件 | 参考文档 |
|---|---|---|
| G2 EVM 仿真 | Anvil + Go 仿真器 StateDB | §3.2 · §8.1 |
| G3 不变性断言 | Go 仿真器执行结果、PreState/PostState | §3.2 |
| G4 模糊测试 | Anvil Snapshot/Revert 隔离机制 | §8.1 |
| G5 回测 | ClickHouse 历史数据索引、`IDataProvider` 接口 | §7.1 · §2.4 |
| G6 蒙特卡洛 | G5 回测基线价格序列 | §7.1 |
| G7 影子模式 | `ShadowTrade` gRPC、治理哨兵状态 | §2.1 · §5.2 · §8.2 |
| G8 灰度验证 | FSM STAGED 状态、STAGED 绝对阈值审批 | §3.3 · §5.1 |

---

*上一篇：[7.1 回测引擎与数据接口](./7.1_回测引擎与数据接口.md) | 下一篇：[8.1 Go 仿真器参考实现](../08_参考实现/8.1_Go仿真器参考实现.md)*
