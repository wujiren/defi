# 7.1 回测引擎与数据接口 (Backtest Engine & Data Interface)

> **文档类型：** 架构文档 · 验证与回测篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [2.4 历史数据归档](../02_数据总线与契约/2.4_历史数据归档.md) · [3.2 验证层：EVM 仿真与三源预言机](../03_核心执行引擎/3.2_验证层_EVM仿真与三源预言机.md)
> **下游文档：** [7.2 验证门控 G1-G8 对齐](./7.2_验证门控G1-G8对齐.md)
>
> **来源文档：** `模块_9_验证门控_G1-G8.md` G5/G6 回测部分；PRD `验证门控标准说明文档` §5（G5 回测标准）·§6（G6 蒙特卡洛标准）；PRD `开发者旅程说明文档` §3（本地验证阶段）·§4（多场景评估阶段）
>
> **关键角色：** 回测引擎是策略从 `DRAFT` 推进至 `EVALUATED` 的必经门控（G5/G6），同时也是 AI 反馈飞轮生成评估报告的数据来源（§6.4）。

---

## 1. 设计原则

回测系统遵循两条核心原则，防止回测结果虚高：

**原则 1：零 Look-Ahead（无前向偏差）**
策略在历史时间点 `t` 做出决策时，只能访问 `t` 时刻之前的数据，严禁访问 `t+1` 及之后的数据。系统通过逐区块回放（Block-by-Block Replay）机制从物理层强制执行此约束。

**原则 2：开发者代码零 RPC**
策略代码在回测期间不发起任何真实 RPC 调用，所有链上状态由回测引擎注入。这与实盘完全一致（见 §8.2 Python Agent 基类）——策略代码无需区分自己在回测环境还是实盘环境中运行。

---

## 2. 数据接口层（`IDataProvider`）

回测引擎通过 `IDataProvider` 接口向策略代码注入历史数据，该接口与实盘的数据访问接口完全一致，实现环境透明切换。

### 2.1 接口定义

```python
# data_provider.py

from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Optional

class IDataProvider(ABC):
    """
    策略代码的唯一数据访问入口。
    回测引擎注入 BacktestDataProvider，实盘注入 LiveDataProvider。
    策略代码无需知道底层数据来源。
    """

    @abstractmethod
    def get_price(
        self,
        token_address: str,
        block_number: int,
    ) -> Optional[Decimal]:
        """
        获取指定代币在指定区块的价格（USDC 本位）。
        回测实现：从归档历史数据读取，严格不超越 block_number。
        实盘实现：从三源预言机中位价获取（见 §3.2）。
        """
        pass

    @abstractmethod
    def get_pool_state(
        self,
        pool_address: str,
        block_number: int,
    ) -> Optional[dict]:
        """
        获取指定 AMM 池在指定区块的状态（sqrtPriceX96、tick、liquidity 等）。
        回测实现：从 L2 归档数据读取协议解析后的池状态。
        """
        pass

    @abstractmethod
    def get_account_balance(
        self,
        token_address: str,
        block_number: int,
    ) -> Decimal:
        """
        获取策略账户在指定区块的代币余额。
        回测实现：由引擎维护的虚拟账户余额（不访问链上）。
        """
        pass
```

### 2.2 `BacktestDataProvider` 实现

```python
# backtest_data_provider.py

class BacktestDataProvider(IDataProvider):
    """
    回测专用数据提供器，从 S3/MinIO 归档数据中提供历史快照。
    使用 ClickHouse 作为高速索引（见 §2.4）加速区块级查询。
    """

    def __init__(self, clickhouse_client, current_block: int):
        self._ch = clickhouse_client
        self._current_block = current_block  # 回放引擎逐块推进此值
        self._virtual_balances: dict[str, Decimal] = {}  # 虚拟账户余额

    def get_price(self, token_address: str, block_number: int) -> Optional[Decimal]:
        # 严格校验：不允许查询超过当前回放区块的数据
        if block_number > self._current_block:
            raise LookAheadError(
                f"Look-ahead forbidden: requested block {block_number} "
                f"> current replay block {self._current_block}"
            )

        result = self._ch.execute(
            "SELECT median_price FROM oracle_prices "
            "WHERE token_address = %(token)s AND block_number <= %(block)s "
            "ORDER BY block_number DESC LIMIT 1",
            {"token": token_address, "block": block_number}
        )
        return Decimal(result[0][0]) if result else None

    def get_pool_state(self, pool_address: str, block_number: int) -> Optional[dict]:
        if block_number > self._current_block:
            raise LookAheadError(f"Look-ahead forbidden at block {block_number}")

        result = self._ch.execute(
            "SELECT sqrt_price_x96, tick, liquidity, fee_growth_global0, fee_growth_global1 "
            "FROM pool_states "
            "WHERE pool_address = %(pool)s AND block_number <= %(block)s "
            "ORDER BY block_number DESC LIMIT 1",
            {"pool": pool_address, "block": block_number}
        )
        if not result:
            return None
        row = result[0]
        return {
            "sqrt_price_x96":      int(row[0]),
            "tick":                int(row[1]),
            "liquidity":           int(row[2]),
            "fee_growth_global0":  int(row[3]),
            "fee_growth_global1":  int(row[4]),
        }

    def get_account_balance(self, token_address: str, block_number: int) -> Decimal:
        # 返回引擎维护的虚拟账户余额，不查链上
        return self._virtual_balances.get(token_address, Decimal("0"))

    def apply_trade(self, token_in: str, amount_in: Decimal,
                    token_out: str, amount_out: Decimal, gas_cost: Decimal) -> None:
        """回测引擎在仿真交易执行后，更新虚拟账户余额"""
        self._virtual_balances[token_in]  = self._virtual_balances.get(token_in, Decimal("0")) - amount_in
        self._virtual_balances[token_out] = self._virtual_balances.get(token_out, Decimal("0")) + amount_out
        # Gas 费用从 ETH 余额中扣除
        self._virtual_balances["ETH"]     = self._virtual_balances.get("ETH", Decimal("0")) - gas_cost
```

---

## 3. 回测执行引擎

### 3.1 逐区块回放架构

```python
# backtest_engine.py

class BacktestEngine:
    """
    G5 回测引擎核心：逐区块回放历史数据，驱动策略产生决策，
    使用 Anvil 分叉仿真真实执行，记录每笔交易的 PnL 和指标。
    """

    def __init__(self, config: BacktestConfig, anvil_rpc: str):
        self.cfg = config
        self.anvil_rpc = anvil_rpc

    def run(
        self,
        strategy_agent: "BaseStrategyAgent",
        start_block: int,
        end_block: int,
        initial_capital: Decimal,
    ) -> "BacktestReport":

        data_provider = BacktestDataProvider(self.clickhouse, start_block)
        strategy_agent.set_data_provider(data_provider)   # 注入回测数据源
        strategy_agent.set_is_backtest(True)              # 关闭真实 RPC 访问

        # 初始化虚拟账户
        data_provider.apply_initial_capital(initial_capital)

        report = BacktestReport(strategy_id=strategy_agent.agent_id)
        nav_history: list[NAVSnapshot] = []

        # 逐区块回放
        for block in range(start_block, end_block + 1):
            data_provider._current_block = block           # 推进水位线

            try:
                # 1. 策略产生决策（与实盘相同代码路径）
                proposals = strategy_agent.on_block(block)

                for proposal in proposals:
                    # 2. EVM 仿真（使用 Anvil 历史分叉）
                    sim_result = self._simulate_on_fork(proposal, block)

                    if sim_result.success:
                        # 3. 应用虚拟账户变化
                        data_provider.apply_trade(
                            proposal.token_in,  sim_result.amount_in,
                            proposal.token_out, sim_result.amount_out,
                            sim_result.gas_cost,
                        )
                        report.record_trade(block, proposal, sim_result)

            except LookAheadError as e:
                # Look-Ahead 违规：记录错误，测试失败
                report.add_error(block, "LOOK_AHEAD_VIOLATION", str(e))

            # 4. 每区块快照 NAV
            nav = data_provider.calc_nav(block)
            nav_history.append(NAVSnapshot(block=block, nav=nav))

        # 5. 计算最终指标
        report.finalize(nav_history)
        return report

    def _simulate_on_fork(self, proposal, block: int):
        """在 Anvil 历史区块分叉上执行 EVM 仿真"""
        # fork_at_block 将 Anvil 回滚至历史区块状态，确保仿真使用真实历史流动性
        anvil_fork = AnvilFork(self.anvil_rpc, fork_block=block)
        return anvil_fork.simulate(proposal.to_unsigned_tx())
```

### 3.2 回测配置参数

```python
@dataclass
class BacktestConfig:
    # 回测时间范围
    start_block:     int          # 回测开始区块
    end_block:       int          # 回测结束区块

    # 初始资本
    initial_capital_usdc: Decimal  # 初始资金（USDC）

    # Gas 模型（影响净收益计算）
    gas_model:    str             # "historical"（使用历史 Gas）/ "fixed"（固定值）
    gas_price_gwei: Decimal       # 仅 gas_model="fixed" 时有效

    # 数据源
    clickhouse_dsn: str           # ClickHouse 连接串
    anvil_rpc:      str           # Anvil 节点 RPC

    # 滑点模型
    use_real_slippage: bool = True  # True：用链上实际成交量模拟滑点
                                    # False：使用 max_slippage_bps 固定值（低估成本）
```

---

## 4. G5 回测评估指标计算

G5 门控要求回测结果达到 PRD 设定的最低标准（见 §7.2 G5 定义）。

### 4.1 核心指标计算

```python
class BacktestReport:
    """G5 回测报告：计算并输出所有评估指标"""

    def finalize(self, nav_history: list[NAVSnapshot]) -> None:
        navs = [s.nav for s in nav_history]

        # 年化收益率
        total_return = (navs[-1] - navs[0]) / navs[0]
        days = (nav_history[-1].block - nav_history[0].block) / 7200  # ~7200 blocks/day
        self.annualized_return = (1 + float(total_return)) ** (365 / days) - 1

        # 年化波动率
        returns = [(navs[i] - navs[i-1]) / navs[i-1] for i in range(1, len(navs))]
        self.annualized_volatility = float(np.std(returns) * np.sqrt(365 * 7200))

        # Sharpe Ratio（无风险利率按 4% 年化计算）
        risk_free_daily = 0.04 / 365
        self.sharpe_ratio = (
            (self.annualized_return - 0.04) / self.annualized_volatility
            if self.annualized_volatility > 0 else 0
        )

        # 最大回撤（MDD）
        peak = navs[0]
        max_dd = Decimal("0")
        for nav in navs:
            if nav > peak:
                peak = nav
            dd = (peak - nav) / peak
            if dd > max_dd:
                max_dd = dd
        self.max_drawdown_pct = float(max_dd) * 100

        # Gas 成本占比
        total_gross_pnl = sum(t.gross_pnl for t in self.trades)
        total_gas_cost  = sum(t.gas_cost for t in self.trades)
        self.gas_cost_ratio = (
            float(total_gas_cost / total_gross_pnl) * 100
            if total_gross_pnl > 0 else 100.0
        )

        # 资金利用率（每区块 NAV 实际部署比例的均值）
        self.capital_utilization = float(
            np.mean([s.deployed_ratio for s in nav_history])
        ) * 100

    def passes_g5_gate(self) -> tuple[bool, list[str]]:
        """检验是否通过 G5 门控标准（来自 PRD §5）"""
        failures = []

        if self.sharpe_ratio < 1.0:
            failures.append(f"Sharpe Ratio {self.sharpe_ratio:.2f} < 1.0 (hard floor)")

        if self.max_drawdown_pct > 20.0:
            failures.append(f"Max Drawdown {self.max_drawdown_pct:.1f}% > 20% (hard limit)")

        if self.annualized_return < 0.10:
            failures.append(f"Annualized return {self.annualized_return:.1%} < 10% (primary target)")

        if self.gas_cost_ratio > 30.0:
            failures.append(f"Gas cost ratio {self.gas_cost_ratio:.1f}% > 30% (cost threshold)")

        if self.capital_utilization < 40.0:
            failures.append(f"Capital utilization {self.capital_utilization:.1f}% < 40% (efficiency floor)")

        return len(failures) == 0, failures
```

---

## 5. G6 蒙特卡洛压力测试

G6 要求在 5000 轮随机路径扰动下，评估策略的稳健性（来自 PRD §6）。

```python
class MonteCarloEngine:
    """
    G6 蒙特卡洛引擎：对历史数据进行随机扰动，生成 5000 条路径，
    检验策略在不同市场情景下的表现稳定性。
    """

    NUM_ROUNDS = 5000
    POSITIVE_RETURN_THRESHOLD = 0.60   # 60% 以上路径须为正收益（PRD G6 标准）

    def run(
        self,
        strategy_agent: "BaseStrategyAgent",
        base_backtest: BacktestReport,
        perturbation_config: "PerturbationConfig",
    ) -> "MonteCarloReport":

        results: list[float] = []

        for i in range(self.NUM_ROUNDS):
            # 1. 对历史价格序列施加随机扰动
            perturbed_prices = self._perturb_price_series(
                base_backtest.price_series,
                volatility_scale=perturbation_config.vol_scale,   # 波动率缩放（0.5–2.0）
                drift_shift=perturbation_config.drift_range,       # 随机漂移（±5%）
                liquidity_shock=perturbation_config.liquidity_shocks,  # 随机流动性冲击
            )

            # 2. 在扰动路径上运行轻量回测（跳过 EVM 仿真，用解析模型近似）
            round_result = self._run_fast_backtest(strategy_agent, perturbed_prices)
            results.append(round_result.total_return)

        report = MonteCarloReport(
            num_rounds=self.NUM_ROUNDS,
            returns=results,
        )
        return report

    def _perturb_price_series(
        self, base_prices: list[Decimal],
        volatility_scale: float,
        drift_shift: tuple[float, float],
        liquidity_shocks: int,
    ) -> list[Decimal]:
        """对基础价格序列施加三类扰动"""
        prices = [float(p) for p in base_prices]

        # 扰动 1：重新采样波动率（几何布朗运动扰动）
        log_returns = np.diff(np.log(prices))
        scaled_returns = log_returns * volatility_scale
        scaled_returns += np.random.uniform(*drift_shift, size=len(scaled_returns)) / len(prices)

        # 扰动 2：随机插入流动性冲击（价格瞬间跳动 ±10%）
        shock_indices = np.random.choice(len(scaled_returns), size=liquidity_shocks, replace=False)
        for idx in shock_indices:
            scaled_returns[idx] += np.random.choice([-0.1, 0.1])

        # 重建价格序列
        perturbed = [prices[0]]
        for r in scaled_returns:
            perturbed.append(perturbed[-1] * np.exp(r))

        return [Decimal(str(p)) for p in perturbed]
```

```python
class MonteCarloReport:
    def __init__(self, num_rounds: int, returns: list[float]):
        self.num_rounds = num_rounds
        self.returns = returns
        self.positive_ratio = sum(1 for r in returns if r > 0) / num_rounds
        self.p5_return = float(np.percentile(returns, 5))    # 极端不利情景
        self.p95_return = float(np.percentile(returns, 95))  # 极端有利情景
        self.median_return = float(np.median(returns))

    def passes_g6_gate(self) -> tuple[bool, list[str]]:
        """检验是否通过 G6 门控标准（来自 PRD §6）"""
        failures = []

        if self.positive_ratio < self.POSITIVE_RETURN_THRESHOLD:
            failures.append(
                f"Positive return ratio {self.positive_ratio:.1%} < 60% "
                f"({int(self.positive_ratio * self.num_rounds)}/{self.num_rounds} rounds positive)"
            )

        if self.p5_return < -0.30:  # P5 极端情景不得超过 -30%
            failures.append(
                f"P5 extreme scenario return {self.p5_return:.1%} < -30% (tail risk too high)"
            )

        return len(failures) == 0, failures
```

---

## 6. 评价标准

| 维度 | 好架构 | 坏架构 |
|---|---|---|
| **零 Look-Ahead** | 物理级别阻断（`LookAheadError` 抛出），回测引擎不可绕过 | 仅靠开发者自律，策略代码可能无意中访问未来数据 |
| **代码路径一致** | 策略代码在回测和实盘中运行同一套逻辑，`IDataProvider` 透明切换 | 回测代码和实盘代码是两套独立实现，"回测通过但实盘失败" |
| **EVM 精度** | G5 回测使用 Anvil 历史分叉仿真，模拟真实链上执行 | 用固定滑点参数近似，Gas 和流动性深度影响被低估 |
| **蒙卡稳健性** | G6 5000 轮随机扰动，覆盖波动率、漂移、流动性冲击三类风险 | 仅做单一历史路径回测，策略对参数过拟合 |

---

*上一篇：[6.4 AI 反馈飞轮](../06_可观测性/6.4_AI反馈飞轮.md) | 下一篇：[7.2 验证门控 G1-G8 对齐](./7.2_验证门控G1-G8对齐.md)*
