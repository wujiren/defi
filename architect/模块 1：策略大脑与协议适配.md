# 🏛️ 模块 1：策略大脑与协议适配 (Strategy & Abstraction)

## 1.1 EVM 仿真数学库 (Fixed-Point Simulation Engine)

为了彻底消除链下浮点数与链上整数除法差异导致的“回测陷阱”，系统采用**计算对称性设计**。

* **设计模式**：在 Go 执行层中，强制使用 `math/big` 库结合 `go-ethereum` 的 `params` 常量，模拟 Solidity 的溢出检查和舍入方向。
* **位级对齐 (Bit-aligned)**：确保任何逻辑运算（如 $A \times B / C$）在 Go 仿真器中的结果与链上 EVM 执行结果误差为 **0**。
* **验收标准**：必须通过 **G2（EVM 精度关卡）** 回归测试，确保回测收益估算与实盘完全一致。

---

## 1.2 协议适配器注册表 (Adapter Registry)

这是系统支持多链、多协议的工程基础，实现了策略决策与底层合约逻辑的深度解耦。

* **抽象接口**：定义统一的 `IAdapter` 接口，屏蔽不同协议（如 Uniswap V3 vs V4）的底层差异。
* **注册表机制**：AI 策略不直接持有合约地址，而是通过协议 ID 向注册表索取适配器。
* **热更新**：协议升级时仅需更新全局适配器，无需修改上层 AI 策略代码。

### Go 技术实现：IAdapter 接口定义

在 Go 执行层中，协议适配器必须实现以下核心契约：

```go
// IAdapter 定义了所有链上协议的通用操作规范
type IAdapter interface {
    // GetQuote 获取链上实时报价 (Geth 调用)
    GetQuote(ctx context.Context, amountIn *big.Int, path []common.Address) (*big.Int, error)

    // EncodeTrade 将 AI 的决策逻辑编码为链上字节码 (Calldata)
    EncodeTrade(req *TradeRequest) ([]byte, error)

    // GetRiskParams 获取该协议当前的风险参数 (如池子流动性深度)
    GetRiskParams(ctx context.Context, poolAddress common.Address) (*ProtocolRisk, error)
}

// Registry 负责管理所有的适配器实例
type AdapterRegistry struct {
    adapters map[string]IAdapter // key 为协议 ID，如 "UNISWAP_V3_ETH"
}

func (r *AdapterRegistry) GetAdapter(protocolID string) (IAdapter, bool) {
    adapter, ok := r.adapters[protocolID]
    return adapter, ok
}

```

---

## 1.3 治理风险感知哨兵 (Governance Sentinel)

* **自动监控**：采用分布式爬虫实时抓取 Snapshot、Tally 提案。
* **熔断触发**：捕获到“修改 LTV”或“增加手续费”等重大提案时，哨兵通过 `AdapterRegistry` 标记相关协议为“高风险”，自动触发 FSM 熔断或提前撤资。

---

## 1.4 模块 1 评价标准 (Evaluation Standards)

| 维度 | **好架构 (Industrial Grade)** | **坏架构 (Junior Level)** |
| --- | --- | --- |
| **计算一致性** | 链下仿真显示赚 **1.000001 ETH**，实盘即为 **1.000001 ETH**。 | 回测显示大赚，实盘因为精度丢失导致滑点超限被拦截。 |
| **扩展速度** | 接入新 DEX 协议仅需编写一个适配器实现 `IAdapter`。 | 每次新协议上线都要修改全局发单逻辑和风控模块。 |
| **解耦程度** | AI 仅负责决策（买什么/买多少），Go 负责编码（Calldata 生成）。 | AI 策略中硬编码了大量的合约方法名和 ABI 逻辑。 |
| **进化能力** | AI 能够根据历史误差数据自动调整 Adapter 的滑点参数。 | 同样的错误在不同协议中反复出现，缺乏统一修复能力。 |
