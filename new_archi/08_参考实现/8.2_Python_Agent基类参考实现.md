# 8.2 Python Agent 基类参考实现 (Python Agent Base Class Reference)

> **文档类型：** 架构文档 · 参考实现篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.1 策略 Agent 与水位线拦截](../03_核心执行引擎/3.1_策略Agent与水位线拦截.md) · [2.1 Protobuf 契约](../02_数据总线与契约/2.1_Protobuf契约.md)
> **下游文档：** 本文档为最终参考实现，无下游文档
>
> **来源文档：** `Python_策略_Agent_基类实现.md`（完整迁移，补充了 Shadow 模式切换、G4 模糊测试桩函数、回测适配说明）
>
> **定位说明：** `BaseStrategyAgent` 是所有策略 Agent 必须继承的基类。它封装了水位线管理、gRPC 提交、影子/实盘模式切换、精度安全的所有样板代码，使策略开发者专注于业务逻辑（`generate_proposals` 方法），无需关心基础设施细节。

---

## 1. 设计目标

基类的核心设计哲学是**让策略代码零感知基础设施**：

| 策略代码无需关心 | 基类负责处理 |
|---|---|
| 数据是否来自链上还是回测 | `IDataProvider` 接口注入（§7.1） |
| 当前是影子模式还是实盘 | `is_shadow` 参数控制 gRPC 分流（§2.1） |
| `float` 金额精度丢失风险 | `Decimal → str` 强制转换 |
| 水位线是否已滞后 | `last_seen_block` 检查和 `StaleDataError` 感知 |
| gRPC 连接管理 | 基类持有 gRPC channel，子类无需关心 |

---

## 2. 基类完整实现

```python
# base_strategy_agent.py

import uuid
import time
import logging
from abc import ABC, abstractmethod
from decimal import Decimal, ROUND_DOWN
from typing import Optional

import grpc
from defi_proto.trading_pb2 import TradeRequest, TradeAction
from defi_proto.common_pb2 import Context, BigAmount
from defi_proto.trading_pb2_grpc import TradingEngineStub

logger = logging.getLogger(__name__)


class BaseStrategyAgent(ABC):
    """
    DeFi 策略 Agent 基类。
    所有生产策略 Agent 必须继承此类，并实现 generate_proposals() 方法。

    关键约定：
    - 策略代码中禁止直接调用任何 RPC 接口（G1 静态分析会拦截）
    - 所有金额必须使用 Decimal 类型，禁止 float
    - 策略代码通过 self.data 访问市场数据（IDataProvider）
    """

    def __init__(
        self,
        agent_id: str,
        grpc_endpoint: str,
        is_shadow: bool = False,
    ):
        self.agent_id = agent_id
        self.is_shadow = is_shadow          # True: 影子模式（G7 门控）
        self._is_backtest = False           # True: 回测模式（G5/G6 门控）

        # 水位线状态（见 §3.1）
        self.last_seen_block: int = 0

        # gRPC 连接（基类持有，子类无需关心）
        self._channel = grpc.insecure_channel(grpc_endpoint)
        self._stub    = TradingEngineStub(self._channel)

        # 数据提供器（实盘注入 LiveDataProvider，回测注入 BacktestDataProvider）
        self.data: Optional["IDataProvider"] = None

    # ────────────────────────────────────────────────────────────────
    # 核心接口：子类必须实现
    # ────────────────────────────────────────────────────────────────

    @abstractmethod
    def generate_proposals(self, block_number: int) -> list["TradeProposal"]:
        """
        策略决策入口：根据当前区块数据生成交易 Proposal 列表。

        约束：
        - 禁止直接访问网络（无 requests.get()、无 web3 调用）
        - 所有数据访问通过 self.data (IDataProvider)
        - 金额必须用 Decimal 类型，不得使用 float

        返回：
        - list[TradeProposal]：空列表表示本区块不交易
        """
        pass

    # ────────────────────────────────────────────────────────────────
    # 水位线管理
    # ────────────────────────────────────────────────────────────────

    def update_watermark(self, block_number: int) -> None:
        """
        更新 Agent 本地水位线。
        由 Redis Stream 消费循环在每个新区块事件到达时调用（见 §2.2 §3.1）。
        """
        if block_number > self.last_seen_block:
            self.last_seen_block = block_number

    def is_data_fresh(self, current_chain_block: int) -> bool:
        """
        在 generate_proposals() 前主动检查本地水位线是否足够新鲜。
        这是 Zone A 侧的辅助检查，Zone B 的 Sync Sentinel 是安全底线（§3.1 DDR-1）。
        """
        lag = current_chain_block - self.last_seen_block
        if lag > 2:
            logger.warning(
                "data stale before proposal generation",
                extra={"lag": lag, "last_seen": self.last_seen_block, "chain": current_chain_block}
            )
            return False
        return True

    # ────────────────────────────────────────────────────────────────
    # 事件驱动入口：由 Redis Stream 消费循环调用
    # ────────────────────────────────────────────────────────────────

    def on_block(self, block_number: int) -> list["TradeProposal"]:
        """
        每个新区块事件触发入口。
        Redis Consumer Group 订阅到 ChainEvent 后调用此方法（见 §2.2）。

        流程：
        1. 更新本地水位线
        2. 调用策略决策（generate_proposals）
        3. 对每个 Proposal 提交 gRPC 请求
        """
        self.update_watermark(block_number)

        try:
            proposals = self.generate_proposals(block_number)
        except Exception as e:
            logger.error("generate_proposals raised exception",
                         extra={"block": block_number, "error": str(e)}, exc_info=True)
            return []

        submitted = []
        for proposal in proposals:
            response = self._submit(proposal)
            if response:
                submitted.append(proposal)

        return submitted

    # ────────────────────────────────────────────────────────────────
    # gRPC 提交（含影子/实盘模式分流）
    # ────────────────────────────────────────────────────────────────

    def _submit(self, proposal: "TradeProposal") -> Optional["TradeResponse"]:
        """
        向 Go-Execution-Engine 提交 TradeRequest。
        根据 is_shadow 自动选择 ShadowTrade 或 ExecuteTrade RPC（见 §2.1）。
        """
        trace_id = str(uuid.uuid4())   # 每次 Proposal 生成新 UUID

        ctx = Context(
            trace_id       = trace_id,
            agent_id       = self.agent_id,
            last_sync_block= self.last_seen_block,
            timestamp_ms   = int(time.time() * 1000),
        )

        request = TradeRequest(
            ctx        = ctx,
            protocol_id= proposal.protocol_id,
            action     = proposal.action,
            payload    = proposal.encode_payload(),

            # 精度安全：金额字段强制使用 str，不使用 float（见 §2.1 §5.1 精度保护协议）
            max_slippage_bps= str(int(proposal.max_slippage_bps)),
            gas_price_limit = str(proposal.gas_price_limit_gwei),
        )

        try:
            if self.is_shadow:
                # 影子模式：跑完全部验证逻辑，但在 SIGNED 前物理截断
                response = self._stub.ShadowTrade(request, timeout=5.0)
            else:
                # 实盘模式：完整 FSM 流转
                response = self._stub.ExecuteTrade(request, timeout=5.0)

            logger.info("trade submitted",
                extra={
                    "trace_id":      trace_id,
                    "internal_tx_id": response.internal_tx_id,
                    "status":        response.status,
                    "is_shadow":     self.is_shadow,
                    "protocol":      proposal.protocol_id,
                    "sync_block":    self.last_seen_block,
                }
            )

            # 感知水位线滞后错误（Go 端 Sync Sentinel 拦截）
            if response.error_message == "StaleDataError":
                logger.warning("stale data error from Go Sync Sentinel",
                    extra={"trace_id": trace_id, "sync_block": self.last_seen_block})
                return None

            return response

        except grpc.RpcError as e:
            logger.error("gRPC call failed",
                extra={"trace_id": trace_id, "error": str(e)})
            return None

    # ────────────────────────────────────────────────────────────────
    # 精度安全工具方法
    # ────────────────────────────────────────────────────────────────

    @staticmethod
    def to_wei(amount: Decimal, decimals: int = 18) -> str:
        """
        将 Decimal 金额转换为 Wei 字符串（链上原始整数）。
        强制使用 ROUND_DOWN 避免金额超出余额。

        例：to_wei(Decimal("1.5"), 18) → "1500000000000000000"
        """
        factor = Decimal(10 ** decimals)
        wei = (amount * factor).to_integral_value(rounding=ROUND_DOWN)
        return str(int(wei))

    @staticmethod
    def from_wei(wei_str: str, decimals: int = 18) -> Decimal:
        """
        将 Wei 字符串转换回 Decimal 金额。

        例：from_wei("1500000000000000000", 18) → Decimal("1.5")
        """
        return Decimal(wei_str) / Decimal(10 ** decimals)

    @staticmethod
    def to_big_amount(amount: Decimal, decimals: int, symbol: str) -> BigAmount:
        """
        构建 Protobuf BigAmount 消息（见 §2.1 common.proto）。
        """
        return BigAmount(
            raw_value= BaseStrategyAgent.to_wei(amount, decimals),
            decimals = decimals,
            symbol   = symbol,
        )

    # ────────────────────────────────────────────────────────────────
    # 回测适配（由 BacktestEngine 调用，见 §7.1）
    # ────────────────────────────────────────────────────────────────

    def set_data_provider(self, provider: "IDataProvider") -> None:
        """注入数据提供器（实盘注入 LiveDataProvider，回测注入 BacktestDataProvider）"""
        self.data = provider

    def set_is_backtest(self, is_backtest: bool) -> None:
        """
        切换回测模式。
        回测模式下，on_block() 不触发真实 gRPC 调用；
        BacktestEngine 直接调用 generate_proposals() 并模拟执行。
        """
        self._is_backtest = is_backtest

    # ────────────────────────────────────────────────────────────────
    # 系统状态主动查询（可选，避免无效往返）
    # ────────────────────────────────────────────────────────────────

    def get_system_status(self) -> Optional[int]:
        """
        主动查询 Go 端当前水位线（见 §2.1 GetSystemStatus RPC）。
        在发送 TradeRequest 前可选调用，若发现 Go 端水位线
        与本地 last_seen_block 差值超过阈值，可提前放弃本轮决策，
        避免浪费网络往返并立即收到 StaleDataError。
        """
        try:
            status = self._stub.GetSystemStatus(Empty(), timeout=2.0)
            return status.current_block
        except grpc.RpcError:
            return None
```

---

## 3. 策略子类示例

以下展示一个简单的 USDC/ETH 动量策略，演示如何正确使用基类：

```python
# trend_follower_strategy.py

from decimal import Decimal
from base_strategy_agent import BaseStrategyAgent, TradeProposal
from defi_proto.trading_pb2 import TradeAction


class TrendFollowerStrategy(BaseStrategyAgent):
    """
    基于移动均线交叉的简单趋势跟踪策略。
    演示 BaseStrategyAgent 的正确使用方式。
    """

    def __init__(self, agent_id: str, grpc_endpoint: str, is_shadow: bool = False):
        super().__init__(agent_id, grpc_endpoint, is_shadow)
        self.short_window = 20   # 短期均线区块数
        self.long_window  = 60   # 长期均线区块数
        self.position_pct = Decimal("0.1")  # 每次使用 10% 仓位

    def generate_proposals(self, block_number: int) -> list[TradeProposal]:
        """
        策略核心逻辑：移动均线交叉信号。
        注意：所有数据访问均通过 self.data（IDataProvider），无任何 RPC 调用。
        """
        # 获取当前区块价格（通过 IDataProvider，不直接调 RPC）
        current_price = self.data.get_price(
            token_address="0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",  # WETH
            block_number=block_number,
        )
        if current_price is None:
            return []   # 数据不可用，本区块不交易

        # 计算短期和长期均线（IDataProvider 提供历史价格序列）
        short_ma = self._calc_ma(block_number, self.short_window)
        long_ma  = self._calc_ma(block_number, self.long_window)
        if short_ma is None or long_ma is None:
            return []

        proposals = []

        # 多头信号：短均线上穿长均线
        if short_ma > long_ma:
            usdc_balance = self.data.get_account_balance(
                "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",  # USDC
                block_number,
            )
            trade_amount = usdc_balance * self.position_pct

            if trade_amount > Decimal("100"):   # 最小交易额 $100，避免 Gas 成本占比过高
                proposals.append(TradeProposal(
                    protocol_id     = "UNISWAP_V3_ETH",
                    action          = TradeAction.SWAP,
                    token_in        = "USDC",
                    token_out       = "WETH",
                    amount_in_wei   = self.to_wei(trade_amount, decimals=6),  # USDC 6 位小数
                    max_slippage_bps= Decimal("50"),                          # 0.5% 最大滑点
                    gas_price_limit_gwei= Decimal("50"),
                ))

        return proposals

    def _calc_ma(self, block_number: int, window: int) -> Decimal | None:
        """计算移动均线（纯 Python 计算，无链上调用）"""
        prices = []
        step = max(1, window // 20)  # 均匀采样，不需要每个区块都查
        for blk in range(block_number - window, block_number, step):
            price = self.data.get_price(
                "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", blk
            )
            if price:
                prices.append(price)

        if len(prices) < 5:
            return None
        return sum(prices) / len(prices)
```

---

## 4. Shadow 模式切换说明

`is_shadow` 参数实现了策略在影子模式（G7 门控）和实盘模式之间的无缝切换，**策略代码本身无需任何改动**：

```
                     is_shadow=True（G7 影子模式）
                     ┌─────────────────────────────────────────────────────┐
Python Agent         │  generate_proposals()  →  _submit() → ShadowTrade  │
（相同代码路径）      │                                                      │
                     │  Go 端：EVM 仿真 + 不变性断言 + 水位线校验 全部执行   │
                     │  但在 SIGNED 阶段前物理截断，不发生真实签名           │
                     │  记录假设 PnL 供 G7 门控评估（§7.2）                 │
                     └─────────────────────────────────────────────────────┘

                     is_shadow=False（实盘模式）
                     ┌─────────────────────────────────────────────────────┐
Python Agent         │  generate_proposals()  →  _submit() → ExecuteTrade  │
（相同代码路径）      │                                                      │
                     │  Go 端：完整 FSM 流转，真实 MPC 签名 + 链上广播       │
                     └─────────────────────────────────────────────────────┘
```

**生命周期状态与 `is_shadow` 对应关系：**

| 策略生命周期状态 | `is_shadow` | `_is_backtest` | 真实资金 |
|---|---|---|---|
| DRAFT | — | — | ❌ 无（仅代码阶段）|
| VALIDATED / EVALUATED | False | True | ❌ 无（回测模拟）|
| **SHADOWED（G7）** | **True** | False | ❌ 无（影子截断）|
| STAGED（G8）| False | False | ✅ 有（≤5% 池）|
| LIVE | False | False | ✅ 有（全额）|
| PAUSED | — | — | — |

---

## 5. 常见错误模式与解决方案

### 5.1 float 精度错误（最高危）

```python
# ❌ 错误：float 运算导致精度丢失
amount = 1.5 * 10**18  # float: 1.5e18 = 1499999999999999872 (精度丢失)
proposal.amount = str(int(amount))  # 错误的 Wei 值

# ✅ 正确：Decimal 精度安全
amount = Decimal("1.5")
proposal.amount = self.to_wei(amount, decimals=18)  # "1500000000000000000"
```

### 5.2 直接 RPC 调用（G1 静态分析会拦截）

```python
# ❌ 错误：策略代码直接调用 RPC
from web3 import Web3
w3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/..."))
price = w3.eth.call(...)  # 直接 RPC 调用，违反零 RPC 原则，G1 会拦截

# ✅ 正确：通过 IDataProvider 访问
price = self.data.get_price(token_address, block_number)  # 由基础设施注入
```

### 5.3 水位线不更新

```python
# ❌ 错误：generate_proposals 直接被外部调用，跳过了水位线更新
proposals = agent.generate_proposals(block_number)   # 水位线未更新！

# ✅ 正确：始终通过 on_block 调用，内部自动更新水位线
proposals = agent.on_block(block_number)  # update_watermark() 在内部调用
```

### 5.4 回测泄漏（访问未来数据）

```python
# ❌ 错误：在 generate_proposals 中访问 block_number + 1
future_price = self.data.get_price(token, block_number + 1)  # Look-Ahead 违规！
# BacktestDataProvider 会抛出 LookAheadError（§7.1）

# ✅ 正确：只访问 ≤ block_number 的数据
current_price = self.data.get_price(token, block_number)      # 合法
past_price    = self.data.get_price(token, block_number - 10) # 合法
```

---

## 6. 开发者接入检查清单（Onboarding Checklist）

新策略开发完成后，提交代码 Review 前须确认以下所有项目：

```
代码规范
□ 继承 BaseStrategyAgent，不直接继承 object
□ 只实现了 generate_proposals() 方法（未覆盖 on_block / _submit 等基类方法）
□ 所有金额使用 Decimal，未出现 float 参与金额计算
□ 未出现任何 web3 / requests / http 直接调用
□ 所有 generate_proposals 返回值有明确的 TradeProposal 类型

测试规范
□ 本地用 BacktestDataProvider 跑通了至少 30 天历史回测
□ 回测报告中 Sharpe Ratio ≥ 1.0（通过 G5 自检）
□ 在 is_shadow=True 模式下连续运行 > 1 小时无崩溃（本地 G7 预检）
□ G4 模糊测试 1000 轮零崩溃（可通过 pytest 触发 G4Runner）

提交规范
□ requirements.txt 所有依赖锁定至确定版本
□ strategy_config.yaml 中 protocol_ids 已在 Adapter Registry 注册
□ 代码注释说明了策略核心逻辑和参数选择依据
```

---

*上一篇：[8.1 Go 仿真器参考实现](./8.1_Go仿真器参考实现.md)*

---

## 附录：TradeProposal 数据类

```python
# trade_proposal.py

from dataclasses import dataclass
from decimal import Decimal
from defi_proto.trading_pb2 import TradeAction


@dataclass
class TradeProposal:
    """Python Agent 生成的交易提案，由基类转化为 gRPC TradeRequest"""

    protocol_id:          str            # 目标协议 ID，如 "UNISWAP_V3_ETH"
    action:               TradeAction    # SWAP / ADD_LIQUIDITY / REMOVE_LIQUIDITY
    token_in:             str            # 输入代币地址（0x...）或符号
    token_out:            str            # 输出代币地址（0x...）或符号
    amount_in_wei:        str            # 输入金额（Wei 字符串，使用 to_wei() 转换）
    max_slippage_bps:     Decimal        # 最大滑点（万分位），如 Decimal("50") = 0.5%
    gas_price_limit_gwei: Decimal        # Gas 价格上限（Gwei），如 Decimal("50")
    extra_params:         dict = None    # 协议特定参数（由 Adapter 序列化为 payload bytes）

    def encode_payload(self) -> bytes:
        """将 extra_params 序列化为 Protobuf bytes（由对应 Adapter 处理）"""
        if not self.extra_params:
            return b""
        # 实际实现由各协议 Adapter 提供，此处为占位
        import json
        return json.dumps(self.extra_params).encode()
```
