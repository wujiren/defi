# 3.4 MEV 路由与防夹执行 (MEV Routing & Anti-Sandwich)

> **文档类型：** 架构文档 · 核心执行引擎篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.3 幂等状态机 FSM](./3.3_幂等状态机FSM.md)
> **下游文档：** [3.5 数据库 Schema 汇总](./3.5_数据库Schema汇总.md)
>
> **来源文档：** `模块_8_MEV_路由与防夹执行.md`
>
> **架构定位：** MEV Router 是 Zone B 中独立部署的容器（见 §1.1 DDR-2），在 FSM 推进至 SIGNED 后、链上广播前执行路由决策。它不参与任何签名逻辑，职责单一：**决定把已签名的交易发往哪条路径**。

---

## 1. 为什么需要独立的 MEV 路由层

公共 Mempool 是开放战场——每笔交易在被打包前对所有人可见，MEV 机器人会在探测到高价值交易后立即插入 Front-run 和 Back-run 交易，形成三明治攻击（Sandwich Attack）：

```
攻击者策略（三明治攻击）：
  区块位置 N-1：Front-run  → 用策略 A 拉高价格
  区块位置  N ：策略交易    → 以更高价格成交（受害者）
  区块位置 N+1：Back-run   → 平仓套利

防御手段：Flashbots 私有路由
  交易不广播到 P2P 网络，只发给矿工/验证者
  矿工要么打包，要么静默丢弃——永远不泄露交易内容
```

---

## 2. 双路由架构

### 2.1 路由决策逻辑

```go
// mev_router.go
type MEVRouter struct {
    flashbots  ITxBroadcaster  // 私有路由：Flashbots Relay
    public     ITxBroadcaster  // 公共路由：eth_sendRawTransaction
    gasOracle  GasOracle
    cfg        MEVConfig
}

// RouteAndBroadcast 在 FSM 的 SIGNED → BROADCASTED 阶段调用
func (r *MEVRouter) RouteAndBroadcast(
    ctx context.Context,
    task *TradeTask,
    signedTx *types.Transaction,
) (txHash string, err error) {

    // 路由决策：基于交易价值选择广播路径
    // 配置键: mev_private_route_threshold（默认值见 README §0.6）
    if task.EstimatedValueUSD.Cmp(r.cfg.PrivateRouteThreshold) > 0 {
        // 高价值交易 → 私有路由（Flashbots）
        txHash, err = r.broadcastViaFlashbots(ctx, signedTx)
        if err != nil {
            // Flashbots 失败时降级至公共路由（带告警）
            r.logger.Warn("flashbots broadcast failed, falling back to public mempool",
                zap.String("internal_tx_id", task.ID),
                zap.Error(err),
            )
            txHash, err = r.public.Broadcast(ctx, signedTx)
        }
    } else {
        // 低价值交易 → 公共路由（节省 Flashbots 接入成本）
        txHash, err = r.public.Broadcast(ctx, signedTx)
    }

    return txHash, err
}
```

### 2.2 两条路径的特性对比

| 特性 | 私有路由（Flashbots） | 公共路由（eth_sendRawTransaction） |
|---|---|---|
| **交易可见性** | 仅矿工/验证者可见，上链前完全隐私 | 广播至全网 P2P，MEV 机器人可实时探测 |
| **三明治攻击风险** | ❌ 无（交易不暴露在公共 Mempool） | ⚠️ 有，大额交易尤其危险 |
| **Bundle 失败处理** | 静默失效，**不消耗 Gas** | Revert 时 Gas 仍消耗 |
| **打包延迟** | 可能连续多个区块未被打包（Bundle 竞争激烈） | 通常在 1–3 个区块内打包 |
| **适用场景** | 价值 > `mev_private_route_threshold` 的大额交易 | 小额交易（成本优先） |
| **降级策略** | Flashbots 宕机或 3 个区块未打包时，自动降级 | — |

---

## 3. Flashbots 广播器实现

```go
// flashbots_broadcaster.go

// FlashbotsBroadcaster 实现 ITxBroadcaster 接口
type FlashbotsBroadcaster struct {
    relayURL   string          // Flashbots Relay 端点（如 https://relay.flashbots.net）
    authSigner *ecdsa.PrivateKey // Bundle 身份签名密钥（非交易私钥，仅用于身份认证）
    client     *flashbots.Client
    maxRetry   int             // Bundle 未被打包时的最大区块重试次数（默认 3）
}

// Broadcast 将已签名交易封装为 Bundle 并发送至 Flashbots Relay
func (f *FlashbotsBroadcaster) Broadcast(
    ctx context.Context,
    signedTx *types.Transaction,
) (string, error) {

    currentBlock, _ := f.rpc.GetLatestBlock(ctx)

    // 1. 构建 Bundle（目标下一个区块）
    bundle := &flashbots.Bundle{
        Txs:         []*types.Transaction{signedTx},
        BlockNumber: currentBlock + 1,
    }

    // 2. 模拟 Bundle（预检：确认不会 Revert）
    simResult, err := f.client.SimulateBundle(ctx, bundle)
    if err != nil {
        return "", fmt.Errorf("bundle simulation failed: %w", err)
    }
    if simResult.HasRevert {
        return "", fmt.Errorf("bundle simulation shows revert: %s", simResult.RevertReason)
    }

    // 3. 提交 Bundle，并在连续多个区块重试（配置键由 maxRetry 控制）
    for attempt := 0; attempt < f.maxRetry; attempt++ {
        targetBlock := currentBlock + uint64(attempt) + 1
        bundle.BlockNumber = targetBlock

        resp, err := f.client.SendBundle(ctx, bundle, f.authSigner)
        if err != nil {
            f.logger.Warn("bundle send failed", zap.Int("attempt", attempt), zap.Error(err))
            continue
        }

        // 等待下一个区块，检查是否被打包
        time.Sleep(12 * time.Second) // Ethereum 出块时间约 12 秒
        receipt, err := f.rpc.GetTransactionReceipt(ctx, signedTx.Hash().Hex())
        if err == nil && receipt != nil {
            // Bundle 被打包
            return resp.BundleHash, nil
        }

        f.logger.Info("bundle not included, retrying next block",
            zap.Uint64("target_block", targetBlock),
            zap.String("bundle_hash", resp.BundleHash),
        )
    }

    // 超过最大重试次数，返回错误由调用方降级至公共路由
    return "", fmt.Errorf("bundle not included after %d blocks", f.maxRetry)
}
```

---

## 4. 公共 Mempool 广播器实现

```go
// public_broadcaster.go

type PublicBroadcaster struct {
    rpc RPCClient
}

func (p *PublicBroadcaster) Broadcast(
    ctx context.Context,
    signedTx *types.Transaction,
) (string, error) {
    // 直接调用 eth_sendRawTransaction
    txHash, err := p.rpc.SendRawTransaction(ctx, signedTx)
    if err != nil {
        return "", fmt.Errorf("public broadcast failed: %w", err)
    }
    return txHash, nil
}
```

---

## 5. 与 FSM 的交互协议

MEV Router 是 FSM SIGNED → BROADCASTED 状态转换的**执行方**，不自行修改 FSM 状态：

```
FSM（3.3）                              MEV Router（3.4）
────────────────────                    ──────────────────────────────────
task.status = SIGNED
     │
     │ 调用 RouteAndBroadcast(task, signedTx)
     └────────────────────────────────→
                                        路由决策（Flashbots vs Public）
                                        广播执行
                                        ← 返回 (txHash, error)
     │
     ├── 成功：db.UpdateTask(BROADCASTED, txHash)
     └── 失败：db.UpdateTask(FAILED, errorMsg)
              触发 §6.3 P1 告警
```

**幂等性保证：** MEV Router 是无状态服务，相同的 `signedTx` 可以安全重复调用（Flashbots Bundle 重复提交幂等，公共路由的重复 Nonce 会被节点拒绝）。Recovery Manager（§3.3）负责检测到 SIGNED 无 tx_hash 时重新调用。

---

## 6. 降级策略与告警

| 场景 | 触发条件 | 处理方式 | 告警级别 |
|---|---|---|---|
| Flashbots Relay 宕机 | `SendBundle` 连接超时 | 立即降级至公共路由 | P2（非紧急） |
| Bundle 连续未被打包 | 超过 `maxRetry` 个区块 | 降级至公共路由 | P2 |
| 公共路由也失败 | `SendRawTransaction` 返回错误 | FSM → FAILED，P1 告警 | P1 |
| Bundle 模拟 Revert | `SimulateBundle` 返回 Revert | 不发送，FSM → FAILED | P1（仿真已通过但 Bundle 模拟失败，需排查） |

---

## 7. Gas Tip 策略（Flashbots Bundle 竞争）

Flashbots 生态中，矿工按 Bundle 的总 Miner Tip（coinbase 转账 + priority fee）排序打包。若 Bundle 长期未被打包，可能是因为 Tip 不够有竞争力：

```go
// 计算有竞争力的 Miner Tip（简化示意）
func (f *FlashbotsBroadcaster) calcMinerTip(
    gasUsed uint64,
    baseFee *big.Int,
) *big.Int {
    // Tip = gas_used × priority_fee_per_gas
    // 当前市场推荐 priority fee 从 Gas Oracle 获取
    suggestedPriorityFee, _ := f.gasOracle.SuggestPriorityFee()

    tip := new(big.Int).Mul(
        new(big.Int).SetUint64(gasUsed),
        suggestedPriorityFee,
    )
    return tip
}
```

Bundle Tip 策略目前使用 Gas Oracle 的市场推荐值，未来可接入 MEV-share 协议优化竞争策略。

---

*上一篇：[3.3 幂等状态机 FSM](./3.3_幂等状态机FSM.md) | 下一篇：[3.5 数据库 Schema 汇总](./3.5_数据库Schema汇总.md)*
