# 4.1 双分录会计系统 (Double-Entry Ledger System)

> **文档类型：** 架构文档 · 财务与结算篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.3 幂等状态机 FSM](../03_核心执行引擎/3.3_幂等状态机FSM.md) · [3.5 数据库 Schema 汇总](../03_核心执行引擎/3.5_数据库Schema汇总.md)
> **下游文档：** [4.2 资产估值与审计](./4.2_资产估值与审计.md)
>
> **来源文档：** `模块_4_财务会计与数据水位线.md` §4.2 · §4.4（财务部分）；`数据基础设施_基于_Redis_Stream_的_Pub-Sub_流转拓扑.md` §3.3 Saga 跨链在途处理
>
> **与 §3.5 的分工：** 本文档只描述**业务逻辑**（什么时候记什么分录、如何保证账实相符）。所有 SQL Schema 定义（`accounts`、`ledger_entries`、`asset_balances`、`unclaimed_rewards` 表结构）统一见 §3.5，本文档通过引用而非重复定义。

---

## 1. 设计原则

系统采用**金融级双分录会计（Double-Entry Bookkeeping）**，核心约束是：

> **任何一笔链上资产变动，必须在内部账本同时产生借方（Debit）和贷方（Credit）两条分录，且借贷金额严格相等。**

这一约束保证了系统账本的自洽性：即使发生软件 Bug、RPC 异常或网络中断，资产也不会在账本中"凭空消失"或"无中生有"。

**三类资产必须追踪：**

| 资产类型 | 定义 | 更新触发 |
|---|---|---|
| **已实现资产（Realized）** | 链上已确认的余额变动 | FSM 状态推进至 `CONFIRMED` |
| **未领取奖励（Unclaimed）** | 协议内积累但未领取的 Reward | 定时任务每 5–10 分钟扫描 |
| **公允价值（MtM）** | 持仓按三源预言机中位价的实时估值 | 每区块更新，见 §4.2 |

**为什么缺一不可：** 若只追踪"已实现资产"而忽略"未领取奖励"，NAV（净资产价值）会被低估，风控模块可能误判为回撤触发熔断；若 MtM 不实时更新，AI 决策基于的仓位估值将失真。

---

## 2. 账户体系

所有账户在 `accounts` 表中定义（Schema 见 §3.5），按类型分为三类：

```
账户体系
├── STRATEGY 账户（每个策略一个）
│   └── 记录策略持有的各代币余额和未领取奖励
├── PROTOCOL 账户（每个协议一个）
│   └── 记录流入/流出各 DeFi 协议的资金
└── GAS 账户（全局一个）
    └── 单独追踪所有策略的 Gas 消耗，防止 Gas 成本被掩盖在交易 PnL 中
```

**账户命名约定：**
- 策略账户：`STRATEGY_{strategy_id}`
- 协议账户：`PROTOCOL_{protocol_id}_{chain_id}`（如 `PROTOCOL_UNISWAP_V3_1`）
- Gas 账户：`GAS_POOL`

---

## 3. 标准分录规则

### 3.1 Swap 交易（Token A → Token B）

```
触发时机：FSM 状态推进至 CONFIRMED

借方（Debit）：  STRATEGY 账户  +Token B 金额
贷方（Credit）： STRATEGY 账户  -Token A 金额
借方（Debit）：  GAS 账户       +Gas 费用（USDC 折算）
贷方（Credit）： STRATEGY 账户  -Gas 费用（USDC 折算）

约束：借贷金额以 Wei 为单位（NUMERIC(78,0)），不使用浮点数
```

**Go 实现伪代码：**

```go
// PostTrade 在 FSM CONFIRMED 后由对账模块调用
func (l *Ledger) PostTrade(task *TradeTask, receipt *TradeReceipt) error {
    return l.db.Transaction(func(tx *gorm.DB) error {
        // 1. 写入 Token In（贷方：策略账户减少）
        if err := tx.Create(&LedgerEntry{
            InternalTxID:    task.ID,
            TraceID:         task.TraceID,
            DebitAccountID:  protocolAccountID,   // PROTOCOL 账户
            CreditAccountID: strategyAccountID,   // STRATEGY 账户
            Amount:          receipt.AmountIn,
            EntryType:       "TRADE",
        }).Error; err != nil {
            return err
        }

        // 2. 写入 Token Out（借方：策略账户增加）
        if err := tx.Create(&LedgerEntry{
            InternalTxID:    task.ID,
            TraceID:         task.TraceID,
            DebitAccountID:  strategyAccountID,   // STRATEGY 账户
            CreditAccountID: protocolAccountID,   // PROTOCOL 账户
            Amount:          receipt.AmountOut,
            EntryType:       "TRADE",
        }).Error; err != nil {
            return err
        }

        // 3. 写入 Gas 费用（单独记录，不混入交易 PnL）
        gasCostUSDC := l.calcGasCostUSDC(receipt.GasUsed, receipt.GasPrice)
        if err := tx.Create(&LedgerEntry{
            InternalTxID:    task.ID,
            TraceID:         task.TraceID,
            DebitAccountID:  gasPoolAccountID,    // GAS 账户
            CreditAccountID: strategyAccountID,   // STRATEGY 账户
            Amount:          gasCostUSDC,
            EntryType:       "GAS_FEE",
        }).Error; err != nil {
            return err
        }

        // 4. 同步更新 asset_balances 表的水位线
        return l.updateAssetBalance(tx, strategyAccountID, receipt)
    })
}
```

> **原子性保证：** 所有分录在同一个数据库事务中写入。任何一条失败，整个事务回滚，不产生"半截分录"。

### 3.2 流动性添加（Add Liquidity）

```
触发时机：FSM 状态推进至 CONFIRMED

借方：PROTOCOL 账户    +LP Token 或仓位凭证
贷方：STRATEGY 账户   -Token A 金额
贷方：STRATEGY 账户   -Token B 金额
借方：GAS 账户        +Gas 费用
贷方：STRATEGY 账户   -Gas 费用
```

### 3.3 奖励领取（Claim Reward）

```
触发时机：FSM 状态推进至 CONFIRMED（Claim 交易）

借方：STRATEGY 账户   +Reward Token 金额
贷方：PROTOCOL 账户   -Reward Token 金额（协议内积累清零）
借方：GAS 账户        +Gas 费用
贷方：STRATEGY 账户   -Gas 费用

联动：同步清零 unclaimed_rewards 表中对应记录
```

### 3.4 未领取奖励追踪（定时扫描）

奖励在协议合约内积累，不产生链上 Transfer 事件，只能通过主动调用合约查询。

```go
// ScanUnclaimedRewards 定时任务，每 5-10 分钟执行
func (s *RewardScanner) ScanUnclaimedRewards(ctx context.Context) error {
    for _, strategy := range s.activeStrategies {
        for _, protocol := range strategy.Protocols {
            // 调用协议合约查询待领取奖励（不产生链上交易）
            pending, err := s.adapter.GetPendingRewards(ctx, strategy.Address, protocol)
            if err != nil {
                continue
            }

            // 更新 unclaimed_rewards 表（Upsert）
            s.db.Upsert(&UnclaimedReward{
                StrategyID:    strategy.ID,
                ProtocolID:    protocol.ID,
                TokenAddress:  pending.Token,
                RawAmount:     pending.Amount,
                LastSyncBlock: s.currentBlock,
            })
        }
    }
    return nil
}
```

**为什么单独追踪：** 未领取奖励不进双分录（因为未发生实际 Transfer），但必须纳入 NAV 计算。否则策略的真实净值会被低估，MtM 估值失真。

---

## 4. 跨链在途资金处理

跨链操作（如 Arbitrum → Ethereum 的资金桥接）期间，资金处于"A 链已发出，B 链未到账"的中间状态，双链账本中均需特殊标记，防止对账差异误报。

### 4.1 在途状态的账本处理

```
发起跨链（A 链 CONFIRMED）：

  借方：BRIDGE_IN_TRANSIT 账户   +金额   ← 在途账户（特殊账户类型）
  贷方：STRATEGY 账户（A 链）    -金额

到账（B 链 CONFIRMED，由跨链监控进程写入）：

  借方：STRATEGY 账户（B 链）   +金额
  贷方：BRIDGE_IN_TRANSIT 账户  -金额   ← 在途清零

超时未到账（30 分钟）：触发 Saga 回滚流程（见下）
```

### 4.2 Saga 回滚流程

```
Redis Stream: stream:internal:accounting
    ↓ 写入"在途"记录（含超时时间戳）
    
跨链监控进程（订阅此 Stream）：
    ├── 30 分钟内收到 B 链 CONFIRMED 事件 → 正常到账，清零在途账户
    └── 30 分钟超时 → 触发 Saga 回滚：
            1. 向 Go-Execution-Engine 发送撤回请求
            2. 等待撤回交易 CONFIRMED
            3. 写反向分录（借方 STRATEGY 账户，贷方 BRIDGE_IN_TRANSIT）
            4. 告警通知管理员
```

**在途资金的 NAV 处理：** 在途期间，`BRIDGE_IN_TRANSIT` 账户的余额计入策略总 NAV，避免跨链期间策略资产"凭空消失"导致风控误触熔断。

---

## 5. 账实核查（Reconciliation）

账实核查是双分录体系的关键验证手段：内部账本余额必须与链上实际余额完全一致。

### 5.1 核查触发时机

| 触发时机 | 核查范围 | 容忍误差 |
|---|---|---|
| 每笔交易 CONFIRMED 后 | 本次交易涉及的账户 | 0（零容忍） |
| 每小时定时全量核查 | 所有活跃策略账户 | 0（零容忍） |
| 管理员手动触发 | 指定账户或全量 | 0（零容忍） |

### 5.2 核查逻辑

```go
// Reconcile 对比内部账本与链上余额
func (r *Reconciler) Reconcile(
    ctx context.Context,
    accountID string,
    tokenAddress string,
    currentBlock uint64,
) error {
    // 1. 读取内部账本余额
    ledgerBalance, err := r.db.GetAssetBalance(accountID, tokenAddress)
    if err != nil {
        return err
    }

    // 2. 读取链上实际余额（指定区块高度，确保与账本水位线一致）
    onChainBalance, err := r.rpc.GetTokenBalance(
        ctx,
        ledgerBalance.Address,
        tokenAddress,
        currentBlock,  // 必须指定区块，禁止使用 latest
    )
    if err != nil {
        return err
    }

    // 3. 比对：零容忍，差值不得超过 1 wei
    diff := new(big.Int).Sub(onChainBalance, ledgerBalance.RawBalance)
    diff.Abs(diff)
    if diff.Cmp(big.NewInt(1)) > 0 {
        // 立即暂停策略，触发人工核查
        r.alertManager.FireCritical("RECONCILIATION_FAILURE", map[string]interface{}{
            "account_id":      accountID,
            "token_address":   tokenAddress,
            "ledger_balance":  ledgerBalance.RawBalance.String(),
            "onchain_balance": onChainBalance.String(),
            "diff":            diff.String(),
            "block":           currentBlock,
        })
        return fmt.Errorf("RECONCILIATION_FAILURE: diff=%s wei", diff.String())
    }

    return nil
}
```

> **为什么对账误差零容忍？** 在 DeFi 高频交易场景中，即使 1 wei 的误差也可能被复利放大，或者隐藏更严重的系统性错误（如 Transfer 事件未被索引到）。零容忍策略强制每次核查都以精确性为标准。

---

## 6. 净收益计算口径

净收益 = 毛收益 − Gas 费用 − 实际滑点损耗 − 协议手续费 − MEV 损耗估算

所有分项均从 `ledger_entries` 表中按 `entry_type` 聚合：

| `entry_type` | 含义 | 计入方向 |
|---|---|---|
| `TRADE` | 交易金额差价（毛收益） | +收益 |
| `GAS_FEE` | 链上 Gas 消耗（USDC 折算） | -成本 |
| `PROTOCOL_FEE` | 协议手续费（如 Uniswap 0.3%） | -成本 |
| `REWARD` | 领取的流动性挖矿奖励 | +收益 |
| `SLIPPAGE` | 实际滑点损耗（见 §4.2） | -成本 |
| `MEV_LOSS` | MEV 损耗估算（见 §4.2） | -成本 |

---

## 7. 评价标准

| 维度 | 好架构 | 坏架构 |
|---|---|---|
| **账实相符度** | 经历 100 笔复杂操作后，内部账本与链上余额误差 ≤ 1 wei | 使用浮点数导致复利计算后净值产生巨大偏差 |
| **分录完整性** | 每笔 CONFIRMED 交易对应 2–4 条分录，借贷平衡可验证 | 只记录"进账"，Gas 成本和协议手续费不单独记录 |
| **原子性** | 分录写入与 FSM 状态推进在同一数据库事务中 | 分录写入和状态更新分两步，崩溃后可能出现"交易成功但账本未更新" |
| **奖励追踪** | 未领取奖励定时扫描并计入 NAV，防止风控误杀 | 只追踪已实现收益，忽略协议内积累的奖励 |
| **跨链覆盖** | 在途资金设专用账户，双链均有记录，30 分钟超时触发 Saga | 跨链期间资金从账本消失，对账告警频繁误报 |

---

*上一篇：[3.5 数据库 Schema 汇总](../03_核心执行引擎/3.5_数据库Schema汇总.md) | 下一篇：[4.2 资产估值与审计](./4.2_资产估值与审计.md)*
