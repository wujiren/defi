# 5.3 全局断路器与时间锁 (Global Kill Switch & Timelock)

> **文档类型：** 架构文档 · 安全防御篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [5.1 MPC 签名与白名单拦截](./5.1_MPC签名与白名单拦截.md) · [5.2 治理风险哨兵](./5.2_治理风险哨兵.md)
> **下游文档：** [6.1 全链路 Trace ID 规范](../06_可观测性/6.1_全链路Trace_ID规范.md)
>
> **来源文档：** `模块_5_安全堡垒与治理风控.md` §5.3 时间锁 + §5.4 全局断路器
>
> **⚠️ 重要澄清（时间锁适用边界）：** 原模块5文档未明确说明时间锁的适用范围。根据 PRD `策略生命周期定义说明文档` §3.6，时间锁（24h 等待期）**仅适用于全局风控参数的修改**（如白名单、滑点阈值、资金比例上限），**不适用于**策略状态流转（STAGED → LIVE 由管理员链下确认即可生效，无需等待期）。本文档在 §2.3 中明确了这一边界。

---

## 1. 全局断路器（Global Kill Switch）

### 1.1 设计目标

面对黑天鹅事件（协议被黑、底层漏洞、市场极端异常），系统需要具备**"核武器"级的响应速度**——在分钟级内完成所有资产的紧急保护，而非依赖繁琐的人工操作序列。

**核心指标：** 从触发 Kill Switch 到完成全量授权撤销，**目标 ≤ 60 秒**。

### 1.2 触发路径

断路器支持三种触发方式，响应时间从快到慢：

| 触发方式 | 响应时间 | 适用场景 |
|---|---|---|
| 管理员 Admin Web Portal 手动点击 | < 5 秒 | 发现异常，主动触发 |
| 治理哨兵自动触发（§5.2 CRITICAL 级提案） | < 30 秒 | 协议治理紧急变更 |
| 外部监控信号（链上异常检测、推特情报） | < 60 秒 | 协议被黑等外部情报 |

### 1.3 断路器执行序列

```
断路器触发
    │
    ├── 1. 立即冻结 Zone B（Go-Execution-Engine）
    │      └── 停止所有 FSM 推进，拒绝新的 TradeRequest 入队
    │
    ├── 2. 撤销所有 Token 授权（Revoke All Approvals）
    │      └── 从预置的 Revoke 模板批量发送交易（见 §1.4）
    │      └── 目标：60 秒内完成
    │
    ├── 3. 执行紧急提款（Emergency Withdrawal）
    │      └── 按"紧急提款函数映射表"依次调用各协议的撤资函数
    │      └── 优先级：高风险协议优先，按持仓规模排序
    │
    └── 4. 告警通知全员
           └── P0 级告警，触发 On-Call 电话/短信通知
```

### 1.4 预置撤销模板

为保障 60 秒响应目标，Revoke 交易不在紧急时刻现场构建，而是**预先生成并存储**：

```go
// RevokeTemplate 预置的授权撤销交易模板
type RevokeTemplate struct {
    ProtocolID   string
    TokenAddress string
    SpenderAddress string       // 需要撤销授权的合约地址
    CallData     []byte         // approve(spender, 0) 的 ABI 编码
}

// KillSwitchExecutor 断路器执行器
type KillSwitchExecutor struct {
    revokeTemplates []RevokeTemplate
    withdrawMap     map[string]WithdrawFunc  // protocol_id → 紧急提款函数
    mpcSigner       MPCSigner
}

// Execute 执行全局断路器
func (k *KillSwitchExecutor) Execute(ctx context.Context, reason string) error {
    startTime := time.Now()

    // 阶段 1：并行发送所有 Revoke 交易（批处理，减少 Gas 消耗）
    var revokeWg sync.WaitGroup
    for _, tmpl := range k.revokeTemplates {
        revokeWg.Add(1)
        go func(t RevokeTemplate) {
            defer revokeWg.Done()
            tx := k.buildRevokeTx(t)
            // 使用优先 Gas 确保快速打包
            tx.SetPriorityFee(k.cfg.EmergencyPriorityFee)
            k.broadcast(ctx, tx)
        }(tmpl)
    }
    revokeWg.Wait()

    k.logger.Info("kill switch revoke phase completed",
        zap.Duration("elapsed", time.Since(startTime)),
        zap.String("reason", reason),
    )

    // 阶段 2：按优先级顺序执行紧急提款
    for _, protocol := range k.sortedProtocolsByRisk() {
        if withdrawFn, ok := k.withdrawMap[protocol]; ok {
            withdrawFn(ctx)
        }
    }

    return nil
}
```

### 1.5 紧急提款函数映射表

系统维护一份各协议的紧急提款函数清单，确保在极端情况下能迅速抽离流动性：

| 协议 | 提款函数 | 注意事项 |
|---|---|---|
| Uniswap V3 | `decreaseLiquidity` + `collect` | 需先减少流动性，再领取 Token |
| Aave V3 | `withdraw(asset, amount, to)` | 借款未还清时需先还款 |
| Compound V3 | `withdraw(asset, amount)` | 直接提款 |
| Curve | `remove_liquidity` | 注意 LP Token 解锁时间 |

---

## 2. 时间锁机制（Admin Timelock）

### 2.1 设计目的

对核心风控参数的修改实施"慢速生效"原则：变更操作提交后，必须等待 24 小时（占位值，可根据团队时区分布调整）才能生效。等待期内，团队所有成员均可审查，发现问题可通过 Guardian 否决。

**防御的威胁模型：** 即使管理员账户被攻陷，攻击者也无法即时修改关键安全参数（需要等待 24 小时，期间可被察觉并取消）。

### 2.2 受时间锁管控的参数（全局风控参数）

| 参数类型 | 示例 | 变更影响 |
|---|---|---|
| 合约白名单 | 新增 / 删除允许的合约地址 | 直接决定哪些合约可以被调用 |
| 全局滑点上限 | `max_slippage_bps` 最大允许值 | 影响所有策略的交易执行边界 |
| 资金池比例上限 | 单策略最大持仓占全局池的上限 | 影响风险集中度控制 |
| 大额审批阈值 | `staged_approval_threshold_usd` | 影响审批触发频率 |
| 水位线容忍度 | `watermark_max_lag` | 影响数据新鲜度的熔断灵敏度 |
| MPC 节点配置 | 分片数量、阈值（M-of-N）| 影响签名安全性 |

### 2.3 时间锁的适用边界（重要澄清）

> ⚠️ **时间锁仅管控全局风控参数修改，不适用于策略状态流转。**

| 操作类型 | 是否受时间锁约束 | 生效方式 |
|---|---|---|
| 修改白名单、滑点阈值等全局参数 | **是**，24h 等待期 | 等待期满且未被 Guardian 否决后自动生效 |
| 策略状态推进（STAGED → LIVE） | **否** | 管理员在链下控制台确认签字即时生效 |
| 策略手动暂停（LIVE → PAUSED） | **否** | 管理员操作立即生效（紧急操作不可延迟） |
| 一键 Kill Switch 触发 | **否** | 立即执行（紧急情况不可设等待期） |

这一区分来自 PRD `策略生命周期定义说明文档` §3.6：策略状态流转是运营决策，需要快速响应；全局参数变更是安全策略，需要充分审查。

### 2.4 时间锁操作流程

```
参数变更请求提交（管理员）
    │
    ├── 写入待生效队列（TimelockQueue），记录：
    │     - 变更内容（参数名、新旧值）
    │     - 提交时间戳
    │     - 操作者身份
    │     - 生效时间 = 提交时间 + 24h
    │
    ├── 向所有管理员发送"参数变更通知"
    │
    ├── 24 小时等待期
    │     └── 任意管理员可审查变更内容
    │     └── Guardian 可在此期间行使否决权（见 §2.5）
    │
    └── 等待期结束
          ├── 未被否决 → 自动应用变更，写入审计日志
          └── 被否决   → 变更取消，记录否决原因
```

```go
// TimelockQueue 时间锁等待队列
type TimelockOperation struct {
    OperationID  string
    ParameterKey string
    OldValue     interface{}
    NewValue     interface{}
    SubmittedAt  time.Time
    EffectiveAt  time.Time  // SubmittedAt + 24h
    SubmittedBy  string
    Status       string     // "pending" | "executed" | "cancelled"
}

// ExecutePending 定时检查并执行到期的变更
func (t *TimelockExecutor) ExecutePending(ctx context.Context) {
    ops, _ := t.db.GetPendingOperations(time.Now())
    for _, op := range ops {
        if op.Status != "pending" || time.Now().Before(op.EffectiveAt) {
            continue
        }
        // 应用参数变更
        t.configStore.Set(op.ParameterKey, op.NewValue)
        t.db.UpdateStatus(op.OperationID, "executed")
        t.auditLog.Write(op, "TIMELOCK_EXECUTED")
    }
}
```

### 2.5 Guardian 否决机制

Guardian 是架构中预留的**高度隔离的否决权账户**，由多签钱包或独立的安全团队持有。

**否决权规则：**
- Guardian 可在时间锁等待期（24h）内**随时**取消任何参数变更
- Guardian 否决操作本身不受时间锁约束（否决是紧急保护机制，不能延迟）
- 每次 Guardian 否决须记录完整的否决原因至审计日志

```go
// GuardianVeto Guardian 否决执行
func (g *Guardian) Veto(operationID string, reason string) error {
    op, err := g.timelockQueue.GetOperation(operationID)
    if err != nil || op.Status != "pending" {
        return fmt.Errorf("operation %s not found or not pending", operationID)
    }

    // 立即取消变更（不受时间锁约束）
    g.timelockQueue.Cancel(operationID)
    g.auditLog.Write(op, "GUARDIAN_VETO", reason)
    g.alertManager.FireWarning("GuardianVetoExercised", map[string]interface{}{
        "operation_id": operationID,
        "parameter":    op.ParameterKey,
        "veto_reason":  reason,
    })
    return nil
}
```

---

## 3. 断路器与时间锁的联动

```
正常情况：
  参数变更 → 时间锁（24h）→ Guardian 审查窗口 → 生效

紧急情况（如发现参数变更提交者账号被盗）：
  Guardian 否决 → 变更取消 → 触发安全审查
  
极端情况（协议被黑，需立即保护资产）：
  Kill Switch 触发 → 绕过时间锁（紧急操作不受等待期约束）
  → 所有 Revoke + 紧急提款立即执行
  → 事后再走时间锁流程修复相关参数
```

---

## 4. 评价标准

| 维度 | 好架构 | 坏架构 |
|---|---|---|
| **响应速度** | Kill Switch 演练 ≤ 60 秒完成全量 Revoke | 紧急时需要手动构造交易，耗时 10+ 分钟 |
| **参数变更安全** | 核心参数修改经 24h 公示，Guardian 可否决 | 单个管理员可即时修改安全参数，无人复核 |
| **时间锁边界清晰** | 全局参数变更走时间锁，策略状态流转不走 | 所有管理操作都走时间锁，紧急暂停策略也要等 24h |
| **预案完备性** | 预置 Revoke 模板和紧急提款映射表，无需临时构建 | 紧急时从零开始构建交易，增加出错风险 |
| **Guardian 机制** | 独立 Guardian 角色可一票否决危险变更 | 参数变更由提交者自行确认，无独立监督 |

---

*上一篇：[5.2 治理风险哨兵](./5.2_治理风险哨兵.md) | 下一篇：[6.1 全链路 Trace ID 规范](../06_可观测性/6.1_全链路Trace_ID规范.md)*
