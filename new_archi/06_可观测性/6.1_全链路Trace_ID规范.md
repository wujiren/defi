# 6.1 全链路 Trace ID 规范 (Full-Chain Trace ID Specification)

> **文档类型：** 架构文档 · 可观测性篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [3.3 幂等状态机 FSM](../03_核心执行引擎/3.3_幂等状态机FSM.md) · [2.1 Protobuf 契约](../02_数据总线与契约/2.1_Protobuf契约.md)
> **下游文档：** [6.2 Prometheus 指标定义](./6.2_Prometheus指标定义.md) · [6.3 告警规则集](./6.3_告警规则集.md)
>
> **来源文档：** `全链路_Trace_ID_的日志规范.md`（完整迁移，补充与 §6.2 Prometheus 的联动）

---

## 1. 设计目标

全链路 Trace ID 机制解决以下核心问题：

- **故障定位：** 一笔交易在哪个环节失败、为什么失败，数秒内可还原完整路径
- **性能诊断：** 从 AI 信号产生到链上确认的各阶段耗时，精确到毫秒
- **闭环反馈：** 链上最终 PnL 结果自动关联回生成该信号的 AI 决策，驱动反馈飞轮（§6.4）
- **合规审计：** 每笔交易的完整决策链可被精确重建，满足机构级资金管理的审计要求

---

## 2. Trace ID 生命周期

Trace ID 在以下关键节点被强制传递，任一节点缺失则请求被网关拒绝：

```
① Python Agent 生成信号
   └── 创建 UUID v4 格式 trace_id
   └── 写入结构化日志（agent_id、sync_block、决策参数）

② gRPC TradeRequest 传输（Zone A → Zone B）
   └── trace_id 装入 Context 字段（见 §2.1）
   └── 网关层验证 trace_id 非空，缺失则返回 INVALID_ARGUMENT

③ PostgreSQL 持久化（Zone B）
   └── 写入 trade_tasks.trace_id 列（见 §3.5）
   └── 后续所有 ledger_entries 均通过此字段关联

④ MPC 签名日志（Zone C）
   └── 签名请求携带 trace_id，写入 HSM 审计日志
   └── 审计签名权限释放的合规依据

⑤ 链上 Event Indexer（CONFIRMED 后）
   └── 通过 tx_hash 反查 trade_tasks，关联 trace_id
   └── 链上执行结果与 AI 决策完成闭环
```

---

## 3. 标准日志格式

系统统一采用 **JSON 结构化日志**，对接 ELK（Elasticsearch + Logstash + Kibana）或 Grafana Loki。

### 3.1 标准字段定义

| 字段 | 类型 | 必填 | 说明 |
|---|---|---|---|
| `trace_id` | `string` | ✅ 必填 | UUID v4，全局唯一，贯穿完整链路 |
| `span_id` | `string` | 选填 | 子任务标识，用于跨链的单跳（Hop）追踪 |
| `component` | `string` | ✅ 必填 | 模块标识：`Strategy_Agent` / `Go_FSM` / `Simulator` / `MPC_Signer` |
| `level` | `string` | ✅ 必填 | `INFO` / `WARN` / `ERROR` / `CRITICAL` |
| `internal_tx_id` | `string` | 选填 | 对应 `trade_tasks` 主键（INIT 阶段后可用） |
| `sync_block` | `int64` | ✅ 必填 | 决策时的数据水位线区块高度，诊断过期数据的关键字段 |
| `msg` | `string` | ✅ 必填 | 描述性文本，使用英文避免日志系统编码问题 |
| `error_code` | `string` | 错误时必填 | 标准错误码，见 §3.3 |
| `duration_ms` | `int64` | 选填 | 该阶段耗时（毫秒），用于性能分析 |
| `timestamp` | `string` | ✅ 必填 | ISO 8601 格式，含时区（UTC） |

### 3.2 各组件日志示例

**Python Agent（信号产生）：**

```python
# 决策触发日志
logger.info("AI decision generated", extra={
    "trace_id":   "550e8400-e29b-41d4-a716-446655440000",
    "component":  "Strategy_Agent",
    "agent_id":   "trend_follower_v2",
    "sync_block": 19238410,
    "protocol_id": "UNISWAP_V3_ETH",
    "action":     "SWAP",
    "msg":        "Moving average crossover detected, proposing SWAP"
})
```

**Go FSM（仿真完成）：**

```go
log.Info("EVM simulation completed",
    zap.String("trace_id",       req.Ctx.TraceId),
    zap.String("component",      "Simulator"),
    zap.String("internal_tx_id", task.ID),
    zap.Uint64("sync_block",     req.Ctx.LastSyncBlock),
    zap.Uint64("gas_used",       result.GasUsed),
    zap.Int64("duration_ms",     time.Since(start).Milliseconds()),
    zap.Bool("success",          true),
)
```

**Go FSM（状态推进）：**

```go
log.Info("FSM state transition",
    zap.String("trace_id",       task.TraceID),
    zap.String("component",      "Go_FSM"),
    zap.String("internal_tx_id", task.ID),
    zap.String("from_state",     "SIMULATED"),
    zap.String("to_state",       "SIGNED"),
    zap.Uint64("nonce",          task.Nonce),
    zap.Int64("duration_ms",     time.Since(start).Milliseconds()),
)
```

**MPC Signer（签名完成）：**

```
{
  "trace_id":       "550e8400-e29b-41d4-a716-446655440000",
  "component":      "MPC_Signer",
  "internal_tx_id": "a1b2c3d4-...",
  "sync_block":     19238410,
  "level":          "INFO",
  "msg":            "MPC signing completed",
  "signer_nodes":   [1, 2, 3],
  "timestamp":      "2026-02-26T10:30:00.123Z"
}
```

### 3.3 标准错误码

| 错误码 | 触发模块 | 含义 |
|---|---|---|
| `STALE_DATA_ERROR` | §3.1 Sync Sentinel | 数据水位线滞后超过阈值 |
| `ORACLE_PRICE_SKEW` | §3.2 三源预言机 | 三源价格偏差超过 0.5% |
| `INVARIANT_BROKEN` | §3.2 不变性断言 | 仿真结果违反物理底线 |
| `SIMULATION_REVERT` | §3.2 EVM 仿真 | 仿真执行失败（链上会 Revert） |
| `WHITELIST_VIOLATION` | §5.1 白名单代理 | 目标合约不在白名单 |
| `APPROVAL_REQUIRED` | §5.1 MPC 协调器 | 触发大额审批阈值，交易挂起 |
| `NONCE_CONFLICT` | §3.3 Nonce 锁 | Nonce 分配冲突 |
| `GOVERNANCE_CRITICAL` | §5.2 治理哨兵 | 底层协议存在 CRITICAL 级治理风险 |
| `BUNDLE_NOT_INCLUDED` | §3.4 MEV Router | Flashbots Bundle 超重试次数未打包 |
| `RECONCILIATION_FAILURE` | §4.1 对账模块 | 账本余额与链上余额不一致 |

---

## 4. 跨组件传递实现

### 4.1 Python → Go（gRPC Context 传递）

```python
class BaseStrategyAgent:
    def create_context(self) -> Context:
        return Context(
            trace_id=str(uuid.uuid4()),     # 每次决策生成新 UUID
            agent_id=self.agent_id,
            last_sync_block=self.last_seen_block,
            timestamp_ms=int(time.time() * 1000)
        )
```

### 4.2 Go 内部（zap logger 上下文传播）

```go
// 在 FSM 处理开始时，将 trace_id 注入到上下文 logger
func (h *TradeHandler) Handle(ctx context.Context, req *TradeRequest) {
    logger := h.logger.With(
        zap.String("trace_id", req.Ctx.TraceId),
        zap.String("agent_id", req.Ctx.AgentId),
    )
    // 后续所有子函数调用均传入此 logger，无需重复传递 trace_id
    h.simulate(ctx, logger, req)
}
```

### 4.3 链上 Event 闭环（Indexer 关联）

```go
// EventIndexer 在交易 CONFIRMED 后执行闭环
func (idx *EventIndexer) OnConfirmed(txHash string, blockNumber uint64) {
    // 通过 tx_hash 反查数据库，获取 trace_id
    task, err := idx.db.GetTaskByTxHash(txHash)
    if err != nil {
        return
    }

    log.Info("transaction confirmed on-chain",
        zap.String("trace_id",    task.TraceID),
        zap.String("tx_hash",     txHash),
        zap.Uint64("block",       blockNumber),
        zap.String("component",   "EventIndexer"),
    )

    // 触发 AI 反馈飞轮（见 §6.4）
    idx.feedbackLoop.Enqueue(task.TraceID, txHash, blockNumber)
}
```

---

## 5. 异常监控与自动告警

通过 Trace ID 关联，系统实现以下自动告警（详细阈值见 §6.3）：

| 监控场景 | 检测条件 | 触发告警 | 关联 Prometheus 指标 |
|---|---|---|---|
| 端到端延迟过高 | `INIT → SIGNED` 跨度 > 500ms | P2 性能预警 | `fsm_transition_duration_ms` |
| 交易卡死 | `BROADCASTED` 状态 > 5 分钟无 `tx_hash` 更新 | P1 告警 + 自动阶梯 Gas 加速 | `fsm_stuck_total` |
| 毒性流反向收割 | 模块 4.2 审计命中 | P2 告警 → 写入 AI 飞轮 | `toxic_flow_detected_total` |
| 水位线滞后 | `current_block - sync_block > 2` | P0 CRITICAL | `watermark_lag_blocks` |
| 签名拒绝率异常 | 单小时内 `WHITELIST_VIOLATION` > 3 次 | P0 安全告警 | `whitelist_violation_total` |

---

## 6. 日志存储与查询

### 6.1 存储策略

| 数据 | 存储方案 | 保留期 | 说明 |
|---|---|---|---|
| 实时日志流 | Grafana Loki / ELK | 30 天 | 用于实时故障排查 |
| 结构化日志归档 | S3 / MinIO（Parquet 格式） | 永久 | 用于合规审计和 AI 飞轮训练 |
| MPC 审计日志 | Zone C HSM 内加密存储 | 永久 | 不可篡改，合规要求 |

### 6.2 典型查询场景

```
# 查询指定 trace_id 的完整链路（Loki PromQL）
{job="defi-system"} | json | trace_id="550e8400-e29b-41d4-a716-446655440000"

# 查询过去 1 小时的 STALE_DATA_ERROR 频率
{job="defi-system"} | json | error_code="STALE_DATA_ERROR" | rate[1h]

# 查询 P99 FSM 端到端延迟
histogram_quantile(0.99, rate(fsm_transition_duration_ms_bucket[5m]))
```

---

## 7. 评价标准

| 维度 | 好架构 | 坏架构 |
|---|---|---|
| **故障定位速度** | 数秒内通过 trace_id 还原交易全路径，含仿真 Log 和 MPC 日志 | 手动登录不同服务器，对比时间戳猜测失败原因 |
| **水位线可追溯** | 日志中明确记录 `sync_block`，可判断 AI 决策是否基于过期数据 | 无法确认决策时参考的价格是否新鲜 |
| **PnL 闭环** | 链上实际 PnL 自动通过 trace_id 反馈给 AI Agent（§6.4） | AI 引擎不知道自己的决策在链上的真实表现 |
| **合规审计** | 每笔签名操作可追溯到 AI 决策和管理员审批记录 | 签名日志与业务日志割裂，无法还原完整审批链 |

---

*上一篇：[5.3 全局断路器与时间锁](../05_安全防御/5.3_全局断路器与时间锁.md) | 下一篇：[6.2 Prometheus 指标定义](./6.2_Prometheus指标定义.md)*
