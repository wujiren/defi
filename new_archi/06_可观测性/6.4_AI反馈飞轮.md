# 6.4 AI 反馈飞轮 (AI Feedback Loop)

> **文档类型：** 架构文档 · 可观测性篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [4.2 资产估值与审计](../04_财务与结算/4.2_资产估值与审计.md) · [6.3 告警规则集](./6.3_告警规则集.md)
> **下游文档：** [7.1 回测引擎与数据接口](../07_验证与回测/7.1_回测引擎与数据接口.md)
>
> **来源文档：**
> - `模块_6_全链路可观测.md`（§1 数据流转、§2 Prompt 模板、§3 技术实现）
> - PRD `评估指标体系说明文档` §10（AI 优化建议生成规则）
> - PRD `策略生命周期定义说明文档` §3.8（DEPRECATED 策略的 AI 利用）
>
> **与已有文档的分工：**
> - §4.2 负责**生成**审计数据（软滑点、毒性流）
> - §6.3 负责**触发告警**
> - 本文档负责将审计结果和历史数据**转化为 AI 可消费的优化 Prompt**，驱动策略迭代

---

## 1. 飞轮设计目标

AI 反馈飞轮解决的核心问题是：**AI 策略如何从自己的链上执行结果中持续学习**。

```
链上执行结果
    │
    ├── 交易 CONFIRMED → 软滑点 / 毒性流审计（§4.2）
    ├── 策略 DEPRECATED → 全量历史数据归档
    └── 门控未通过 → 失败原因结构化输出
    │
    ▼
反馈飞轮处理（本文档）
    │
    ├── 数据采集与清洗
    ├── 评分到 Prompt 的转化
    └── 向量化存储与历史检索
    │
    ▼
AI 策略优化
    │
    ├── Python Agent 参数调整（短期记忆）
    └── 新策略 DRAFT 的优化方向建议（长期学习）
```

**飞轮时效要求：** 交易 CONFIRMED 后 **60 秒内**生成反馈 Prompt，写入 AI-Feedback-Service 队列。

---

## 2. 数据采集流水线

### 2.1 数据来源

| 数据类型 | 来源 | 触发时机 | 传输方式 |
|---|---|---|---|
| 软滑点审计结果 | §4.2 `SoftSlippageAudit` | 交易 CONFIRMED 后立即 | Redis Stream `stream:internal:accounting` |
| 毒性流分析结果 | §4.2 `ToxicFlowDetector` | 确认区块 +10 区块后 | Redis Stream `stream:internal:accounting` |
| FSM 失败详情 | §3.3 FSM 状态推进日志 | FSM 推进至 FAILED | Redis Stream `stream:agent:proposals` |
| 水位线拦截记录 | §3.1 Sync Sentinel | `StaleDataError` 触发时 | Redis Stream `stream:chain:events` |
| 策略评估报告 | §7.2 G5/G6 门控完成后 | 评估阶段完成 | PostgreSQL `evaluation_reports` 表 |
| 退役策略数据 | 策略生命周期 §3.8 | 策略进入 DEPRECATED | 归档任务批处理 |

### 2.2 Go 端数据采集实现

```go
// FeedbackCollector 收集交易执行数据并发送至飞轮队列
type FeedbackCollector struct {
    redis      *redis.Client
    db         *gorm.DB
    auditSvc   *Auditor
    priceOracle OracleAggregator
}

// OnTradeConfirmed 在 FSM 推进至 CONFIRMED 时调用
func (f *FeedbackCollector) OnTradeConfirmed(
    ctx context.Context,
    task *TradeTask,
    receipt *TradeReceipt,
) error {
    start := time.Now()

    // 1. 软滑点审计（立即执行）
    slippageResult := f.auditSvc.SoftSlippageAudit(task, receipt)

    // 2. 构建反馈事件（毒性流分析异步在 +10 区块后执行，见 §4.2）
    event := &FeedbackEvent{
        TraceID:       task.TraceID,
        StrategyID:    task.StrategyID,
        AgentID:       task.AgentID,
        AuditType:     "TRADE_CONFIRMED",
        SlippageBps:   slippageResult.ActualBps,
        ExpectedSlippageBps: slippageResult.ExpectedBps,
        GasUsed:       receipt.GasUsed,
        GasPriceGwei:  receipt.GasPrice,
        SyncBlockLag:  receipt.ConfirmedBlock - task.LastSyncBlock,
        Protocol:      task.ProtocolID,
        Timestamp:     time.Now(),
    }

    // 3. 写入 Redis Stream（AI-Feedback-Service 异步消费）
    payload, _ := proto.Marshal(event)
    f.redis.XAdd(ctx, &redis.XAddArgs{
        Stream: "stream:internal:accounting",
        Values: map[string]interface{}{
            "type":    "FEEDBACK_EVENT",
            "payload": payload,
        },
    })

    f.logger.Info("feedback event enqueued",
        zap.String("trace_id", task.TraceID),
        zap.Int64("elapsed_ms", time.Since(start).Milliseconds()),
    )
    return nil
}
```

---

## 3. Prompt 模板设计

AI-Feedback-Service（Zone A）消费 Redis Stream 中的事件，按事件类型选择对应模板生成 Prompt。

### 3.1 模板 A：交易执行失败/熔断分析

**适用场景：** FSM 推进至 `FAILED`，或被 Sync Sentinel / 预言机熔断拦截。

```python
FAILURE_ANALYSIS_TEMPLATE = """
System: 你是一个高级 DeFi 策略分析师。请根据以下实盘反馈分析失败原因，并给出具体的参数调整建议。

执行上下文：
- Trace ID: {trace_id}
- 策略 ID: {strategy_id}
- 目标协议: {protocol_id}
- 失败错误码: {error_code}
- 失败详情: {error_message}
- 决策时水位线区块: {sync_block}
- 实际链上区块: {chain_block}
- 水位线滞后: {block_lag} 个区块
- Gas 价格上限（策略设置）: {gas_price_limit} Gwei
- 实际 Gas 价格: {actual_gas_price} Gwei

反思任务：
1. 若错误码为 STALE_DATA_ERROR：
   - 评估 Python 推理耗时（当前 {inference_ms}ms）是否超过了 2 个区块的物理阈值
   - 建议：是否需要降低策略的计算复杂度，或提前启动推理流程
   
2. 若错误码为 SIMULATION_REVERT：
   - 分析 max_slippage_bps（当前 {slippage_bps} bps）是否过于保守
   - 分析 {protocol_id} 当前流动性深度是否支撑交易规模 {amount_usdc} USDC
   
3. 若错误码为 ORACLE_PRICE_SKEW：
   - 三源价格偏差（{deviation_bps} bps）超过阈值，属系统性保护，无需参数调整
   - 评估是否需要降低该协议的交易频率

请输出：
- 根因分析（1-3 句）
- 具体参数修正建议（JSON 格式）
- 预期改善效果
"""
```

### 3.2 模板 B：执行效率与毒性流审计

**适用场景：** 交易成功（CONFIRMED），但软滑点或毒性流指标异常。

```python
POST_TRADE_AUDIT_TEMPLATE = """
System: 你的交易已成交，但账本审计发现执行效率异常。请复盘并优化执行策略。

执行报告：
- Trace ID: {trace_id}
- 协议: {protocol_id}，Token 对: {token_pair}
- 交易方向: {action}，交易规模: {amount_usdc} USDC
- 已实现 PnL: {pnl_usdc} USDC

执行质量指标：
- 预期滑点: {expected_slippage_bps} bps
- 实际软滑点: {actual_slippage_bps} bps（偏差: {slippage_deviation_bps} bps）
- MEV 损耗估算: {mev_loss_bps} bps
- 广播路由: {route_type}（{route_reason}）
- 执行后 10 区块价格变化: {price_change_bps} bps

毒性流分析: {toxic_flow_detected}
{toxic_flow_detail}

优化方向评估：
1. 若实际滑点 > 预期滑点 × 2：
   - 评估 {protocol_id} 当前流动性深度（{liquidity_depth_usdc} USDC）与交易规模的比例
   - 考虑是否将单笔交易拆分为 TWAP 分批执行

2. 若检测到毒性流（price_change < -{threshold} bps）：
   - 当前广播路由为 {route_type}
   - 若使用公共路由，建议切换至 Flashbots 私有路由（§3.4）
   - 评估信号生成频率是否过于规律，导致被 MEV 机器人识别

3. 若 MEV 损耗 > 30 bps：
   - 此次损耗估算为 {mev_loss_usdc} USDC，占交易规模的 {mev_loss_ratio}%
   - 建议：交易规模 > ${flashbots_threshold} 时强制使用 Flashbots 路由

请输出：
- 执行质量评价（优秀/正常/需改进）
- 具体参数修正建议（JSON 格式）
- 下次同类交易的执行建议
"""
```

### 3.3 模板 C：评估门控未通过分析

**适用场景：** 策略在 G5 回测或 G6 蒙特卡洛阶段未通过，进入重评估循环。

```python
EVALUATION_FAILURE_TEMPLATE = """
System: 你的策略在评估阶段未通过门控标准，需要根据评估报告调整策略参数或逻辑。

评估报告摘要（来自 §7.2 G5/G6 门控）：
- 策略 ID: {strategy_id}，策略类型: {strategy_type}
- 评估时间范围: {start_block} – {end_block}

未达标指标（仅列出 FAIL 项）：
{failed_metrics_list}

综合评分: {overall_score}/100（收益 {return_score} · 风险 {risk_score} · 成本 {cost_score} · 效率 {efficiency_score}）

各未达标指标详情：
{metric_details}

历史相似失败案例（来自 Vector DB 检索）：
{similar_failures}

优化建议生成任务：
针对每个未达标指标，给出：
1. 参数级别的调整建议（如 max_position_size、rebalance_threshold）
2. 逻辑级别的改进方向（如执行时机、仓位管理方式）
3. 建议的验证方式（重新回测的参数范围）

请以 JSON 格式输出优化建议，包含字段：
- metric_name, current_value, target_value, suggested_change, confidence
"""
```

---

## 4. 退役策略数据归档与飞轮输入

策略进入 `DEPRECATED` 状态后，历史数据自动转化为飞轮训练语料（对应 PRD 生命周期 §3.8）。

### 4.1 归档数据清单

```go
// StrategyArchiveJob 策略退役时触发的归档任务
type StrategyArchiveJob struct {
    strategyID string
    reason     string  // "manual" | "adapter_failed" | "circuit_breaker_exceeded"
}

func (j *StrategyArchiveJob) Execute(ctx context.Context) error {
    // 1. 从 PostgreSQL 提取完整历史数据
    archive := &StrategyArchive{
        StrategyID:   j.strategyID,
        DeprecatedAt: time.Now(),
        Reason:       j.reason,

        // 执行层数据
        TotalTrades:      j.db.CountTrades(j.strategyID),
        SuccessRate:      j.db.CalcSuccessRate(j.strategyID),
        AvgSlippageBps:   j.db.AvgSlippage(j.strategyID),
        ToxicFlowCount:   j.db.CountToxicFlow(j.strategyID),

        // 财务数据
        TotalPnLUSDC:     j.db.TotalPnL(j.strategyID),
        MaxDrawdownPct:   j.db.MaxDrawdown(j.strategyID),
        SharpRatio:       j.db.SharpRatio(j.strategyID),
        GasCostRatio:     j.db.GasCostRatio(j.strategyID),

        // 失败案例精选（用于负例学习）
        FailedTrades:     j.db.GetFailedTrades(j.strategyID, 100),  // 最多 100 笔

        // 评估报告（G5/G6 原始报告）
        EvaluationReport: j.db.GetLatestEvaluation(j.strategyID),
    }

    // 2. 归档至 S3（Parquet 格式，永久保留）
    j.archiver.SaveToS3(archive, fmt.Sprintf("strategies/%s/archive.parquet", j.strategyID))

    // 3. 生成退役总结 Prompt，写入向量数据库
    summaryPrompt := j.generateDeprecationSummary(archive)
    j.vectorDB.Upsert(j.strategyID, summaryPrompt, archive.GetEmbeddingMetadata())

    return nil
}
```

### 4.2 退役总结 Prompt 模板

```python
DEPRECATION_SUMMARY_TEMPLATE = """
策略归档总结：{strategy_id}
退役原因：{deprecation_reason}
运行周期：{start_date} – {end_date}（{total_days} 天）
策略类型：{strategy_type}，目标协议：{protocol_ids}

总体表现：
- 总交易笔数：{total_trades}，成功率：{success_rate}%
- 累计 PnL：{total_pnl} USDC，日均：{daily_pnl} USDC
- Sharpe Ratio：{sharpe_ratio}，最大回撤：{max_drawdown}%
- Gas 成本占比：{gas_cost_ratio}%，毒性流次数：{toxic_flow_count}

主要失败模式：
{top_failure_patterns}

最终回撤原因：
{final_drawdown_analysis}

对下一代策略的建议：
- 应继承的设计：{inherit_patterns}
- 应避免的错误：{avoid_patterns}
- 参数优化建议：{parameter_suggestions}
"""
```

---

## 5. 向量化存储与历史检索

所有反馈 Prompt 及其对应的 AI 调整决策存入向量数据库，支持相似案例检索。

```python
# feedback_loop.py

class FeedbackLoop:
    def __init__(self, vector_db: VectorDB, llm_client):
        self.vector_db = vector_db
        self.llm = llm_client

    def process_event(self, event: FeedbackEvent) -> None:
        """处理一条反馈事件，生成 Prompt 并调用 AI"""

        # 1. 检索历史相似案例（用于 few-shot 学习）
        similar_cases = self.vector_db.search(
            query=event.to_embedding_text(),
            top_k=3,
            filter={"strategy_type": event.strategy_type}
        )

        # 2. 选择对应 Prompt 模板
        template = self._select_template(event.audit_type)

        # 3. 填充模板，注入相似案例
        prompt = template.format(
            **event.to_dict(),
            similar_failures=self._format_cases(similar_cases)
        )

        # 4. 调用 AI 生成优化建议
        response = self.llm.complete(prompt)
        suggestions = self._parse_suggestions(response)

        # 5. 存储至向量数据库（供未来检索）
        self.vector_db.upsert(
            id=event.trace_id,
            text=prompt + "\n\nAI建议：" + response,
            metadata={
                "strategy_id":   event.strategy_id,
                "strategy_type": event.strategy_type,
                "error_code":    event.error_code,
                "timestamp":     event.timestamp.isoformat(),
                "pnl_usdc":      event.pnl_usdc,
            }
        )

        # 6. 将优化建议推送给对应 Agent（若 Agent 仍在线）
        if suggestions and event.agent_id in self.active_agents:
            self.active_agents[event.agent_id].apply_suggestions(suggestions)

    def _select_template(self, audit_type: str) -> str:
        templates = {
            "TRADE_FAILED":     FAILURE_ANALYSIS_TEMPLATE,
            "TRADE_CONFIRMED":  POST_TRADE_AUDIT_TEMPLATE,
            "EVAL_FAILED":      EVALUATION_FAILURE_TEMPLATE,
        }
        return templates.get(audit_type, FAILURE_ANALYSIS_TEMPLATE)
```

---

## 6. 指标到 Prompt 的转化规则

以下规则定义了哪些评估指标未达标时触发哪类优化 Prompt（来自 PRD 评估指标体系 §8）：

| 未达标指标 | 触发条件 | 生成的优化 Prompt 方向 |
|---|---|---|
| Sharpe Ratio 不达标 | Sharpe < 1.0（系统底线） | 分析收益波动来源，建议调整仓位管理或择时逻辑 |
| 最大回撤超限 | MDD > 20% | 分析回撤区间内的市场条件，建议加严止损或降低杠杆 |
| Gas 成本占比过高 | Gas 占比 > 30% | 建议降低发单频率、增大单笔规模或批量合并操作 |
| 蒙卡正收益占比不足 | < 60% 轮次正收益 | 分析负收益路径的共同特征，建议过滤特定市场条件 |
| 资金利用率过低 | < 40% | 分析闲置资金原因，建议放宽入场条件或增加策略品种 |
| 毒性流频发 | 连续 3 次毒性流 | 建议切换 Flashbots 路由、TWAP 拆单或调整信号生成频率 |
| 软滑点持续偏高 | 实际滑点 > 预期 × 2 | 建议重新评估目标池流动性深度，调整单笔规模 |

---

## 7. 飞轮闭环时序

```
T+0s    交易 CONFIRMED（FSM 状态推进）
  │
T+5s    Go 端生成 FeedbackEvent，写入 Redis Stream
  │
T+10s   AI-Feedback-Service 消费事件，开始处理
  │
T+30s   软滑点分析完成，向量数据库检索相似案例
  │
T+50s   LLM 生成优化 Prompt 和参数建议
  │
T+60s   建议写入向量数据库，推送给对应 Agent
  │
  ├── T+120s（+10区块后）  毒性流分析完成 → 补充推送
  │
  └── （如策略退役）  批处理归档任务 → 生成退役总结语料
```

---

## 8. 评价标准

| 维度 | 好飞轮 | 坏飞轮 |
|---|---|---|
| **反馈时效** | 交易 CONFIRMED 后 60 秒内生成反馈 Prompt | 仅在每周报表中手动复盘，反馈严重滞后 |
| **数据颗粒度** | 包含水位线滞后、仿真 Log、软滑点、毒性流全量指标 | 只告诉 AI 赚了还是赔了，无具体技术损耗分析 |
| **历史检索** | 通过向量数据库检索相似历史失败案例，实现 few-shot 学习 | 每次反馈孤立处理，无历史知识积累 |
| **退役数据利用** | 退役策略数据自动归档为训练语料，系统持续进化 | 退役数据丢弃，同类错误在新策略中重复出现 |
| **学习能力** | AI 能根据错误码（如 STALE_DATA_ERROR）主动优化推理算法耗时 | 同样的精度错误或滑点错误反复出现，无改善 |

---

*上一篇：[6.3 告警规则集](./6.3_告警规则集.md) | 下一篇：[7.1 回测引擎与数据接口](../07_验证与回测/7.1_回测引擎与数据接口.md)*
