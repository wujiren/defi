# 2.1 Protobuf 契约 (Protobuf Contracts)

> **文档类型：** 架构文档 · 数据总线与契约篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [README §0.3 端到端请求链路](../README.md)
> **下游文档：** [2.2 Redis Stream 实时管道](./2.2_Redis_Stream实时管道.md) · [3.1 策略 Agent 与水位线拦截](../03_核心执行引擎/3.1_策略Agent与水位线拦截.md)
>
> **合并说明：** 本文档由以下两份旧文档合并而来，原文档已废弃：
> - `_全套_proto_契约文件汇编.md`（提供完整三文件结构、`data_stream.proto`、`go_package` 选项）
> - `核心交易_Protobuf_契约定义.md`（提供 `GetSystemStatus` RPC、更详细的设计解析）

---

## 1. 契约文件总览

系统跨模块通信（Zone A ↔ Zone B）使用 Protobuf 作为唯一序列化协议，共包含三个 `.proto` 文件：

| 文件名 | 职责 | 消费方 |
|---|---|---|
| `common.proto` | 跨文件共享的基础类型：金额、上下文、状态枚举 | 所有模块 |
| `trading.proto` | 交易执行服务：Python Agent → Go 执行引擎的核心 RPC | §3.1 · §3.3 |
| `data_stream.proto` | 链上事件订阅流：Go 执行引擎 → Python Agent 的实时推送 | §2.2 · §3.1 |

> **编码规范：** 所有金额字段使用 `string` 类型传输链上原始整数（Wei），禁止使用 `float`、`double`、`int64` 表示金额。详见 §4.1 精度保护协议。

---

## 2. `common.proto` — 基础类型定义

该文件定义跨模块共享的原子数据结构，所有其他 `.proto` 文件均 `import` 此文件。

```proto
syntax = "proto3";
package defi.v1;

option go_package = "github.com/holobit/proto/v1;defiv1";

// ── 金额类型 ────────────────────────────────────────────────────────────────

// BigAmount：财务级大数，强制使用 String 传输链上原始整数位（Wei）
// 禁止使用 float/double，防止浮点精度丢失导致链上执行偏差
message BigAmount {
  string raw_value = 1;  // 链上原始整数，例如: "1000000000000000000" (1 ETH)
  int32  decimals  = 2;  // 精度位数，例如: 18
  string symbol    = 3;  // 代币符号，例如: "ETH" / "USDC"
}

// ── 请求上下文 ───────────────────────────────────────────────────────────────

// Context：每个 TradeRequest 必须携带的元数据
// 同时承载全链路追踪 ID 和数据水位线，两者缺一不可
message Context {
  string trace_id       = 1;  // 全链路追踪 ID（UUID v4），由 Python Agent 生成，贯穿全流程
  string agent_id       = 2;  // 发起决策的 AI Agent 唯一标识
  uint64 last_sync_block = 3; // 决策时 Agent 所见的最新区块高度（数据水位线）
  int64  timestamp_ms   = 4;  // 信号产生的 Unix 时间戳（毫秒）
}

// ── 交易状态枚举 ─────────────────────────────────────────────────────────────

// TradeStatus：对应幂等状态机（FSM）的全部状态
// 与 PostgreSQL trade_tasks 表的 status 字段严格对应（见 §3.5）
enum TradeStatus {
  TRADE_STATUS_UNSPECIFIED = 0;  // proto3 零值占位，不应出现在业务逻辑中
  INIT             = 1;          // 任务已创建，分配 Internal Tx ID
  SIMULATED        = 2;          // 通过 EVM 仿真与不变性断言
  PENDING_APPROVAL = 3;          // 触发大额审批阈值，等待管理员确认
  SIGNED           = 4;          // 完成 MPC 分片签名
  BROADCASTED      = 5;          // 已推送至公共 Mempool 或 Flashbots
  CONFIRMED        = 6;          // 链上达到安全确认数，双分录对账完成
  REVERTED         = 7;          // 交易在链上执行失败（Revert）
  FAILED           = 8;          // 系统内部拦截（熔断、白名单拒绝等）
}
```

> **关于 `TRADE_STATUS_UNSPECIFIED = 0`：** proto3 要求枚举的零值必须是默认值。将业务状态 `INIT` 定义为 0 会导致未初始化字段被误判为"已创建"任务，因此以 `UNSPECIFIED` 占位。`FAILED` 状态区别于 `REVERTED`：`REVERTED` 指链上 EVM 执行失败，`FAILED` 指系统在链上广播前已主动拦截。

---

## 3. `trading.proto` — 核心交易服务

定义 Python Agent（Zone A）向 Go 执行引擎（Zone B）提交交易决策的 RPC 接口。

```proto
syntax = "proto3";
package defi.v1;

import "common.proto";

option go_package = "github.com/holobit/proto/v1;defiv1";

// ── 服务定义 ─────────────────────────────────────────────────────────────────

service TradingEngine {

  // ExecuteTrade：实盘交易执行
  // 完整走 FSM 流转（INIT → SIMULATED → SIGNED → BROADCASTED → CONFIRMED）
  // 包含 EVM 仿真、不变性断言、MPC 签名、链上广播全流程
  rpc ExecuteTrade(TradeRequest) returns (TradeResponse);

  // ShadowTrade：影子模式执行
  // 跑完 G1–G7 所有验证逻辑，但在 SIGNED 阶段前物理截断，不进行真实签名和广播
  // 用于 SHADOWED 状态下的预演，对应策略生命周期 G7 门控
  rpc ShadowTrade(TradeRequest) returns (TradeResponse);

  // GetSystemStatus：心跳与状态同步
  // Python Agent 在发送 TradeRequest 前可主动查询 Go 端当前水位线
  // 若返回的 current_block 与本地 last_seen_block 差值超过阈值，
  // Agent 可在本地提前中止，避免无效的 gRPC 往返
  rpc GetSystemStatus(Empty) returns (SystemStatus);
}

// ── 请求消息 ─────────────────────────────────────────────────────────────────

message TradeRequest {
  Context ctx         = 1;  // 必填：包含 Trace ID 和数据水位线
  string  protocol_id = 2;  // 目标协议标识，如 "UNISWAP_V3_ETH"（对应 Adapter Registry）
  TradeAction action  = 3;  // 动作类型
  bytes   payload     = 4;  // 协议特定参数（由各协议 Adapter 负责编解码，见 §3.2）

  // 风控参数（均以 string 传输，防止精度丢失）
  string max_slippage_bps = 5;  // 最大允许滑点，万分位，如 "50" 表示 0.5%
  string gas_price_limit  = 6;  // Gas 价格上限（Gwei），超出则拒绝执行
}

enum TradeAction {
  ACTION_UNSPECIFIED  = 0;
  SWAP                = 1;
  ADD_LIQUIDITY       = 2;
  REMOVE_LIQUIDITY    = 3;
}

// ── 响应消息 ─────────────────────────────────────────────────────────────────

message TradeResponse {
  string      internal_tx_id = 1;  // 数据库 trade_tasks 主键（UUID）
  TradeStatus status         = 2;  // 当前 FSM 状态
  string      tx_hash        = 3;  // 链上交易哈希（BROADCASTED 后填充）
  string      error_message  = 4;  // 失败原因，标准错误码如 "StaleDataError"
}

// ── 心跳消息 ─────────────────────────────────────────────────────────────────

message Empty {}

message SystemStatus {
  uint64 current_block    = 1;  // Go 端当前已确认的最新区块高度
  bool   is_healthy       = 2;  // 系统整体健康状态
  string status_message   = 3;  // 可选的状态说明（如 "RPC node switching"）
}
```

---

## 4. `data_stream.proto` — 链上事件订阅流

定义 Go 执行引擎（Zone B）向 Python Agent（Zone A）推送实时链上事件的流式 RPC 接口，支持 50+ Agent 并发订阅。

```proto
syntax = "proto3";
package defi.v1;

import "common.proto";

option go_package = "github.com/holobit/proto/v1;defiv1";

// ── 服务定义 ─────────────────────────────────────────────────────────────────

service DataSentinel {

  // SubscribeEvents：实时链上事件推送流
  // 服务端流式 RPC（server-streaming）：客户端发起一次订阅，持续接收推送
  // Go 端在每条事件中注入 block_number（数据水位线），Agent 必须校验其新鲜度
  rpc SubscribeEvents(SubscribeRequest) returns (stream ChainEvent);
}

// ── 订阅请求 ─────────────────────────────────────────────────────────────────

message SubscribeRequest {
  string          agent_id     = 1;  // 订阅方的 Agent ID，用于日志和限速
  repeated string protocol_ids = 2;  // 订阅的协议 ID 列表，空列表表示订阅全部
}

// ── 事件消息 ─────────────────────────────────────────────────────────────────

message ChainEvent {
  uint64        block_number   = 1;  // 事件所在区块高度（同时作为数据水位线）
  string        block_hash     = 2;  // 区块哈希（用于检测链重组）
  repeated bytes logs          = 3;  // 原始 ABI 编码的事件日志（Adapter 负责解码）
  int64         server_time_ms = 4;  // Go 端接收到此区块数据的 Unix 时间戳（毫秒）
                                     // Agent 用此字段检测本地处理延迟
}
```

> **与 Redis Stream 的关系：** `DataSentinel` 是 gRPC 层面的抽象接口。实际实现中，Go 端将链上事件写入 Redis Stream（`stream:chain:events`），Python Agent 通过 `XREADGROUP` 消费；`SubscribeEvents` 在内部封装了这一订阅逻辑，使 Agent 代码无需直接感知 Redis。详见 §2.2。

---

## 5. 设计关键点深度解析

### 5.1 精度保护协议

**问题：** 浮点数在跨语言传输和链上整数计算之间存在系统性精度偏差。例如 Python 的 `float(0.1) + float(0.2)` 不等于 `0.3`，而 Solidity 的整数除法会向下取整。

**解决方案：**

```
Python Agent（决策层）      Proto 传输层          Go 执行层（计算层）
─────────────────────        ─────────────         ────────────────────────
Decimal("1000000000")  →→→   string "1000000000"  →→→  big.Int(1000000000)
                              (raw Wei 整数)              math/big 运算
                                                          go-ethereum 原生兼容
```

- Python 侧：使用 `decimal.Decimal` 完成策略逻辑计算，转 `str` 后装入 `BigAmount.raw_value`
- Proto 传输：`string` 类型原样传递，无精度损失
- Go 侧：接收后转 `math/big.Int`，直接对接 `go-ethereum` 的 EVM 仿真库（见 §3.2）

**执行边界：** Python 只做逻辑判断（"该买多少"），不做链上数学（"精确的 tick 价格计算"）。所有涉及链上数学的计算均在 Go 侧完成。

### 5.2 Sync Sentinel 水位线强约束

`Context.last_sync_block` 是 Go 端 Sync Sentinel 的硬拦截依据（详见 §3.1）：

```
Python Agent 发送 TradeRequest
    └── ctx.last_sync_block = 19238410

Go 端 Sync Sentinel 接收请求
    └── current_block = 19238415
    └── lag = 19238415 - 19238410 = 5 > watermark_max_lag (默认 2)
    └── 返回 TradeResponse { error_message: "StaleDataError" }
    └── 请求终止，不进入仿真流程
```

`GetSystemStatus` RPC 为 Agent 提供了主动查询当前水位线的手段，可在本地提前判断是否需要等待数据同步，避免无效的网络往返。

### 5.3 协议适配器解耦（Payload 字段设计）

`TradeRequest.payload` 使用 `bytes` 类型，而非具体的协议消息类型，这是实现协议热插拔的关键：

```
新增 Curve 协议支持：

1. 定义新消息（无需改动 TradingEngine 接口）：
   message CurveSwapParams {
     string pool_address = 1;
     int32  i            = 2;  // 输入代币索引
     int32  j            = 3;  // 输出代币索引
     ...
   }

2. 在 Adapter Registry 注册 "CURVE_3POOL_ETH"

3. Python Agent 序列化后装入 payload：
   payload = CurveSwapParams(...).SerializeToString()

4. Go 端 Adapter 按 protocol_id 查找对应 Adapter，反序列化 payload
```

TradingEngine 的 RPC 接口定义永远不需要修改，新协议通过 Adapter Registry 无感接入。详见 §3.2。

### 5.4 全链路审计保证

`trace_id` 在以下所有节点被强制记录（缺失则请求被网关拒绝）：

| 节点 | 记录位置 | 用途 |
|---|---|---|
| Python Agent 生成信号 | 结构化日志 | 追踪信号产生的策略版本和参数 |
| Go 端接收 TradeRequest | `trade_tasks.trace_id` 列 | 关联数据库任务与链上 tx_hash |
| MPC 签名日志 | HSM 审计日志 | 审计签名权限释放的依据 |
| 链上 Event Indexer | 关联 tx_hash → trace_id | 闭合链上结果与 AI 决策的追踪环 |

详见 §6.1 全链路 Trace ID 规范。

---

## 6. 两份旧文档的差异处理说明

> 本节记录合并时发现的冲突及裁决依据，供审计和后续维护参考。

| 冲突项 | 旧文档 A（全套汇编） | 旧文档 B（核心交易定义） | 裁决结果 | 理由 |
|---|---|---|---|---|
| `TradeStatus` 零值 | `TRADE_STATUS_UNSPECIFIED = 0` | `INIT = 0` | **采用 A** | proto3 规范要求零值为默认值，`INIT = 0` 会导致未初始化字段被误判为已创建任务 |
| `FAILED` 状态 | 有（`= 8`） | 无 | **采用 A** | 系统内部熔断拦截（白名单拒绝、预言机熔断）需要与链上 `REVERTED` 区分 |
| `GetSystemStatus` RPC | 无 | 有 | **采用 B** | 允许 Agent 主动查询水位线，减少无效的 gRPC 往返，对 50+ Agent 场景有实际价值 |
| 文件命名 | `common.proto` / `trading.proto` | `types.proto` / `trading_service.proto` | **采用 A** | A 的命名更简洁，且已包含完整三文件结构 |
| 设计解析深度 | 简要说明 | 详细分点解析 | **采用 B 结构，A+B 内容合并** | B 的分点结构更适合文档查阅 |
| 水位线门控引用 | 错误引用"G7 门控" | 正确引用"Sync Sentinel" | **统一修正为 Sync Sentinel** | G7 是影子模式对比关卡，水位线拦截属于 Sync Sentinel 职责（见 §3.1） |

---

*上一篇：[1.3 网络安全策略](../01_部署架构/1.3_网络安全策略.md) | 下一篇：[2.2 Redis Stream 实时管道](./2.2_Redis_Stream实时管道.md)*
