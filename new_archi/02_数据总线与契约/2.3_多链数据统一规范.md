# 2.3 多链数据统一规范 (Multi-Chain Data Unification)

> **文档类型：** 架构文档 · 数据总线与契约篇
> **版本：** v1.0 · 2026-02-26
> **上游依赖：** [2.2 Redis Stream 实时管道](./2.2_Redis_Stream实时管道.md)
> **下游文档：** [2.4 历史数据归档](./2.4_历史数据归档.md) · [4.1 双分录会计系统](../04_财务与结算/4.1_双分录会计系统.md)
>
> **PRD 主权声明：** 本文档是 PRD《数据基础设施规范》第八节"多链数据统一规范"的**架构实现文档**。
> 业务规范（"统一什么"）定义在 PRD，本文档描述"如何实现"。两份文档发生冲突时，以 PRD 为准。

---

## 1. 问题背景

系统需同时处理多条链（Ethereum 主网、Arbitrum、Base、Optimism 等）的数据。各链在以下维度存在根本性差异，若不统一处理，会导致策略决策、回测对比、跨链对账产生系统性错误：

| 差异维度 | 具体问题 | 不统一的后果 |
|---|---|---|
| **时间轴** | Ethereum 约 12 秒/块，Arbitrum 约 0.25 秒/块，Base 约 2 秒/块 | 用区块高度对齐多链事件会产生严重时序错乱 |
| **代币标识** | USDC 在 Ethereum 是 `0xA0b8...`，在 Arbitrum 是 `0xFF97...` | 同一资产在不同链上地址不同，直接比较会误判为不同资产 |
| **价格基准** | DAI、USDC、USDT 存在微小价差，各链报价精度不同 | 跨链 PnL 对比时因稳定币价差产生虚假损益 |
| **在途资金** | 跨链转账确认期可达 5–30 分钟 | 在途期间双链账本均无该资金，产生对账空洞 |
| **Gas 计量** | ETH 的 gas 用 Gwei，Arbitrum 的 gas 费率结构不同 | 无法跨链比较真实交易成本 |

---

## 2. 规范一：时间基准统一

### 2.1 统一原则

**所有多链事件的时间轴，统一使用 Ethereum 主网区块高度作为锚点（Anchor Block），不使用 Unix 时间戳作为主时间轴。**

理由：Unix 时间戳由矿工/验证者填写，可被轻微操纵；各 L2 链的区块时间戳精度不一致；而 Ethereum 主网区块高度是全网公认的单调递增序列，具有最强的确定性。

### 2.2 跨链区块高度映射表

系统维护一张实时更新的**跨链区块高度映射表**，记录每个 Ethereum 主网区块对应的各 L2 最新区块高度：

```sql
-- 跨链区块高度映射表
CREATE TABLE chain_block_mapping (
    eth_block_number    BIGINT       NOT NULL,  -- Ethereum 主网区块高度（锚点）
    eth_block_timestamp BIGINT       NOT NULL,  -- Ethereum 区块的 Unix 时间戳（秒）
    chain_id            INT          NOT NULL,  -- 目标链 Chain ID
    chain_block_number  BIGINT       NOT NULL,  -- 目标链对应的最新区块高度
    chain_block_hash    VARCHAR(66)  NOT NULL,  -- 目标链区块哈希（用于检测重组）
    synced_at           TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
    PRIMARY KEY (eth_block_number, chain_id)
);

-- 按 chain_id 查询效率优化
CREATE INDEX idx_cbm_chain_eth ON chain_block_mapping(chain_id, eth_block_number DESC);
```

### 2.3 跨链事件时间戳标准化

Data-Processor 在将多链事件写入 Redis Stream 时，必须为每条事件附加 `anchor_eth_block`：

```go
// 标准化多链事件时间戳（Data-Processor 内部逻辑）
type NormalizedChainEvent struct {
    SourceChainID    int    // 事件来源链的 Chain ID
    SourceBlock      uint64 // 事件在来源链上的区块高度
    AnchorEthBlock   uint64 // 对应的 Ethereum 主网锚点区块（统一时间轴）
    AnchorTimestamp  int64  // 锚点区块的 Unix 时间戳（毫秒）
    // ... 其他事件字段
}

func (p *DataProcessor) NormalizeTimestamp(
    event *RawChainEvent,
) (*NormalizedChainEvent, error) {
    // 查询映射表，将来源链区块高度转换为 ETH 锚点区块
    anchorBlock, err := p.db.GetAnchorBlock(event.ChainID, event.BlockNumber)
    if err != nil {
        return nil, fmt.Errorf("anchor block not found for chain %d block %d",
            event.ChainID, event.BlockNumber)
    }
    return &NormalizedChainEvent{
        SourceChainID:   event.ChainID,
        SourceBlock:     event.BlockNumber,
        AnchorEthBlock:  anchorBlock.EthBlockNumber,
        AnchorTimestamp: anchorBlock.EthBlockTimestamp * 1000,
    }, nil
}
```

**边界情况：** 若 L2 区块在 Ethereum 主网两个区块之间产生了多个区块（Arbitrum 约每 12 秒产生 50 个块），则这 50 个 Arbitrum 区块共享同一个 `anchor_eth_block`，通过 `source_block` 区分先后顺序。

---

## 3. 规范二：代币标识统一

### 3.1 统一原则

**系统内部使用 Canonical Token ID 作为唯一代币标识，格式为 `{主网合约地址}:{chain_id_bitmask}`，绝不直接使用各链本地地址作为 key。**

### 3.2 Canonical Token Registry（代币注册表）

```sql
-- 代币注册表：维护跨链同一资产的地址映射
CREATE TABLE canonical_token_registry (
    canonical_id    VARCHAR(100) PRIMARY KEY,  -- 规范 ID，格式: "ETH_MAINNET_ADDR:CHAINS"
                                               -- 例: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48:1,42161,8453"
    symbol          VARCHAR(20)  NOT NULL,     -- 人类可读符号，如 "USDC"
    decimals        INT          NOT NULL,     -- 精度，如 6
    PRIMARY KEY (canonical_id)
);

-- 各链上的本地地址与 canonical_id 的映射
CREATE TABLE token_chain_address (
    canonical_id    VARCHAR(100) NOT NULL REFERENCES canonical_token_registry(canonical_id),
    chain_id        INT          NOT NULL,   -- EIP-155 Chain ID
    local_address   VARCHAR(42)  NOT NULL,   -- 该链上的合约地址（校验和格式）
    is_native       BOOLEAN      NOT NULL DEFAULT FALSE,  -- 是否为链原生代币（ETH/MATIC 等）
    PRIMARY KEY (chain_id, local_address)
);
```

**查询示例：**
```sql
-- 已知 Arbitrum 上的 USDC 地址，查询其 canonical_id
SELECT canonical_id, symbol
FROM token_chain_address
WHERE chain_id = 42161
  AND lower(local_address) = lower('0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8');
-- 返回: canonical_id = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48:1,42161,8453"
--       symbol = "USDC"
```

### 3.3 Adapter Registry 中的代币解析

协议适配器在 `IAdapter.GetQuote()` 返回结果时，必须将本地代币地址转换为 canonical_id（见 §3.2）：

```go
// 适配器内部代币标识转换（示意）
func (a *UniswapV3Adapter) GetQuote(
    ctx context.Context,
    tokenIn common.Address,
    tokenOut common.Address,
    amountIn *big.Int,
) (*Quote, error) {
    // ... 获取链上报价逻辑 ...
    return &Quote{
        TokenInCanonical:  a.registry.ToCanonical(a.chainID, tokenIn),
        TokenOutCanonical: a.registry.ToCanonical(a.chainID, tokenOut),
        AmountIn:          amountIn.String(),
        AmountOut:         amountOut.String(),
    }, nil
}
```

**维护职责：** Canonical Token Registry 由系统管理员维护，新增受支持的链或协议时，需同步更新注册表。策略代码通过 canonical_id 引用代币，不直接使用链上地址。

---

## 4. 规范三：价格基准统一（U 本位）

### 4.1 统一原则

**所有资产的价值统一换算为 USDC 计价（U 本位），精度 6 位小数。跨链比较时以 Ethereum 主网的 USDC 价格为最终基准。**

选择 USDC 而非 USDT 或 DAI 的理由：
- USDC 是 Circle 发行的法币背书稳定币，在链上流动性最强
- USDC 在 Ethereum 主网有 Chainlink 官方价格 Feed，最权威
- 三源预言机中的中位价直接以 USDC 为分母计算，与本规范天然一致

### 4.2 非稳定币资产的 U 本位换算

```python
# SDK DataAPI 内部换算逻辑（示意）
class PriceNormalizer:
    def to_usd_base(
        self,
        canonical_token_id: str,
        amount_raw: int,      # 链上原始整数（Wei 级别）
        at_eth_block: int,    # 使用哪个锚点区块的价格
    ) -> Decimal:
        """
        将任意代币数量换算为 USDC 计价。
        回测时从历史价格表查询；实盘时使用三源预言机中位价。
        """
        token = self.registry.get(canonical_token_id)
        # 1. 将原始整数转换为人类可读数量（考虑 decimals）
        amount = Decimal(amount_raw) / Decimal(10 ** token.decimals)

        # 2. 获取该代币对 USDC 的价格（6 位小数精度）
        price_usdc = self.oracle.get_price_usdc(
            canonical_token_id,
            at_eth_block=at_eth_block,
        )

        # 3. 返回 USDC 计价金额（保留 6 位小数）
        return (amount * price_usdc).quantize(Decimal("0.000001"))
```

### 4.3 稳定币间微小价差处理

DAI、USDT 与 USDC 之间存在最大约 0.1% 的价差。系统处理规则：

- **实盘决策：** 使用三源预言机的实时中位价换算，捕获真实价差
- **对账核查：** USDT/DAI 换算为 USDC 时，采用执行时的实时汇率，不假设 1:1
- **历史回测：** 使用对应 `anchor_eth_block` 时刻的历史汇率，不使用固定 1:1 假设

---

## 5. 规范四：跨链资金在途处理

### 5.1 在途状态定义

跨链资金从 Chain A 发出到 Chain B 确认期间，处于**在途（In-Transit）**状态。在途期间：
- Chain A 账本：资金已离开（借方分录），但目标未确认
- Chain B 账本：资金尚未到达（无贷方分录）
- 若不特殊处理，会出现"资金凭空消失"的对账差异

### 5.2 双链账本在途记录规则

```sql
-- 在途资金跟踪表（配合 §4.1 双分录会计）
CREATE TABLE cross_chain_transit (
    transit_id          UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
    trace_id            VARCHAR(100) NOT NULL,    -- 关联全链路 Trace ID
    from_chain_id       INT          NOT NULL,
    to_chain_id         INT          NOT NULL,
    canonical_token_id  VARCHAR(100) NOT NULL REFERENCES canonical_token_registry(canonical_id),
    amount_raw          NUMERIC(78)  NOT NULL,    -- 原始整数（Wei）
    amount_usd          NUMERIC(20,6),            -- 发出时的 USDC 估值（快照）
    bridge_tx_hash      VARCHAR(66),              -- 链 A 上的跨链 TX Hash
    dest_tx_hash        VARCHAR(66),              -- 链 B 上的到账 TX Hash（到账后填充）
    status              VARCHAR(20)  NOT NULL DEFAULT 'IN_TRANSIT',
                                                  -- IN_TRANSIT / ARRIVED / FAILED / ROLLED_BACK
    initiated_at_eth_block  BIGINT   NOT NULL,    -- 发出时的 ETH 锚点区块
    confirmed_at_eth_block  BIGINT,               -- 到账时的 ETH 锚点区块（到账后填充）
    deadline_eth_block  BIGINT       NOT NULL,    -- 超时 ETH 锚点区块（约 30 分钟后）
    created_at          TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);
```

### 5.3 在途监控与 Saga 回滚

跨链监控进程订阅 `stream:internal:accounting`，处理在途资金的状态流转：

```
跨链操作触发时（Go FSM）：
    1. 向 cross_chain_transit 插入 IN_TRANSIT 记录
    2. 向 stream:internal:accounting 写入在途事件
    3. Chain A 账本记录借方分录（资金减少）
    4. Chain A 账本记录"在途资产"科目贷方（资金未消失，只是在路上）

目标链确认时（Chain B 监控器）：
    1. 更新 cross_chain_transit.status = ARRIVED
    2. 填充 dest_tx_hash 和 confirmed_at_eth_block
    3. Chain B 账本记录贷方分录（资金到账）
    4. Chain A 账本冲销"在途资产"科目

超时未确认时（Saga 回滚，监控进程触发）：
    条件：当前 ETH 块高 > deadline_eth_block
    动作：
        1. 更新 cross_chain_transit.status = ROLLED_BACK
        2. Chain A 账本冲销借方分录（资金归还）
        3. 冲销"在途资产"科目
        4. 发送 P1 告警通知管理员介入检查 Bridge 状态
        5. 相关策略 FSM 标记为 PAUSED，等待人工确认
```

> **超时阈值：** `deadline_eth_block` 默认为 `initiated_at_eth_block + 150`（约 30 分钟，基于 12 秒/块计算）。该值对应系统可配置参数，根据实际桥接协议的确认时间调整。

---

## 6. 规范五：Gas 成本统一计量

### 6.1 统一原则

**各链 Gas 消耗统一折算为 USD，以执行时该链原生代币的 U 本位价格为准，保留 6 位小数精度。**

### 6.2 各链 Gas 折算公式

```
Ethereum 主网：
    gas_cost_usd = gas_used × (base_fee + priority_fee) × ETH_price_usdc / 1e18
    （gas_used 和 fee 均从交易收据读取，ETH_price_usdc 取执行区块的三源中位价）

Arbitrum：
    gas_cost_usd = gas_used × effective_gas_price × ETH_price_usdc / 1e18
    （Arbitrum 的 gas 以 ETH 计价，公式与主网相同）

Base / Optimism：
    gas_cost_usd = (l2_gas_used × l2_gas_price + l1_gas_used × l1_gas_price)
                   × ETH_price_usdc / 1e18
    （OP Stack 链有 L1 数据费和 L2 执行费两部分，需分别计算后求和）
```

### 6.3 Gas 成本写入数据库

FSM 在交易达到 CONFIRMED 状态后，立即计算并持久化 Gas 成本：

```go
// FSM CONFIRMED 后回调（示意）
func (fsm *TradeFSM) onConfirmed(task *TradeTask, receipt *types.Receipt) error {
    gasUSD, err := fsm.gasCalc.CalcGasCostUSD(
        task.ChainID,
        receipt.GasUsed,
        receipt.EffectiveGasPrice,
        task.ConfirmedEthBlock, // 使用确认时的 ETH 锚点区块查询 ETH 价格
    )
    if err != nil {
        return err
    }
    // 写入 trade_tasks 表的 gas_cost_usd 字段（见 §3.5）
    return fsm.db.UpdateGasCost(task.InternalTxID, gasUSD)
}
```

---

## 7. 多链数据统一：组件交互全景

```
                    Canonical Token Registry
                    chain_block_mapping
                    cross_chain_transit
                           │
         ┌─────────────────┼──────────────────┐
         │                 │                  │
    Data-Processor     SDK DataAPI        FSM / 对账模块
  （时间戳标准化）     （价格 U 本位换算）  （在途资金记录）
         │                 │                  │
         └──── Redis Stream（含 anchor_eth_block）─────┘
                           │
               Python Agent（策略决策）
               （消费时看到的是已统一的数据）
```

---

## 8. 各链支持状态

| 链 | Chain ID | 支持状态 | 时间基准锚点 | Gas 折算原生代币 |
|---|---|---|---|---|
| Ethereum 主网 | 1 | ✅ 已支持 | 自身（锚点基准） | ETH |
| Arbitrum One | 42161 | ✅ 已支持 | ETH 主网 | ETH |
| Base | 8453 | ✅ 已支持 | ETH 主网 | ETH |
| Optimism | 10 | ✅ 已支持 | ETH 主网 | ETH |
| Polygon PoS | 137 | 🔧 规划中 | ETH 主网 | MATIC（需额外 MATIC/USD 价格源） |

> 新增链时，需同步完成：① 注册 chain_block_mapping 采集任务；② 在 Canonical Token Registry 添加该链的代币地址映射；③ 实现对应链的 Gas 折算逻辑；④ 更新 Chain-Adapter 的节点配置。

---

*上一篇：[2.2 Redis Stream 实时管道](./2.2_Redis_Stream实时管道.md) | 下一篇：[2.4 历史数据归档](./2.4_历史数据归档.md)*
